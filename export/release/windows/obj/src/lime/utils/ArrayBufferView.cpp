// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferIO
#include <lime/utils/ArrayBufferIO.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_244a612994c6bd06_7_new,"lime.utils.ArrayBufferView","new",0xa2471efa,"lime.utils.ArrayBufferView.new","lime/utils/ArrayBufferView.hx",7,0xb543acf8)
HX_LOCAL_STACK_FRAME(_hx_pos_244a612994c6bd06_279_copyFromArray,"lime.utils.ArrayBufferView","copyFromArray",0x360b3074,"lime.utils.ArrayBufferView.copyFromArray","lime/utils/ArrayBufferView.hx",279,0xb543acf8)
namespace lime{
namespace utils{

void ArrayBufferView_obj::__construct( ::Dynamic elements,int in_type){
            	HX_STACKFRAME(&_hx_pos_244a612994c6bd06_7_new)
HXLINE(  16)		this->bytesPerElement = 0;
HXLINE(   9)		this->type = 0;
HXLINE(  24)		this->type = in_type;
HXLINE(  25)		int _hx_tmp;
HXDLIN(  25)		switch((int)(this->type)){
            			case (int)1: {
HXLINE(  25)				_hx_tmp = 1;
            			}
            			break;
            			case (int)2: {
HXLINE(  25)				_hx_tmp = 2;
            			}
            			break;
            			case (int)3: {
HXLINE(  25)				_hx_tmp = 4;
            			}
            			break;
            			case (int)4: {
HXLINE(  25)				_hx_tmp = 1;
            			}
            			break;
            			case (int)5: {
HXLINE(  25)				_hx_tmp = 1;
            			}
            			break;
            			case (int)6: {
HXLINE(  25)				_hx_tmp = 2;
            			}
            			break;
            			case (int)7: {
HXLINE(  25)				_hx_tmp = 4;
            			}
            			break;
            			case (int)8: {
HXLINE(  25)				_hx_tmp = 4;
            			}
            			break;
            			case (int)9: {
HXLINE(  25)				_hx_tmp = 8;
            			}
            			break;
            			default:{
HXLINE(  25)				_hx_tmp = 1;
            			}
            		}
HXDLIN(  25)		this->bytesPerElement = _hx_tmp;
HXLINE(  29)		bool _hx_tmp1;
HXDLIN(  29)		if (::hx::IsNotNull( elements )) {
HXLINE(  29)			_hx_tmp1 = ::hx::IsNotEq( elements,0 );
            		}
            		else {
HXLINE(  29)			_hx_tmp1 = false;
            		}
HXDLIN(  29)		if (_hx_tmp1) {
HXLINE(  31)			if (::hx::IsLess( elements,0 )) {
HXLINE(  31)				elements = 0;
            			}
HXLINE(  35)			this->byteOffset = 0;
HXLINE(  36)			this->byteLength = (( (int)(elements) ) * this->bytesPerElement);
HXLINE(  37)			 ::haxe::io::Bytes this1 = ::haxe::io::Bytes_obj::alloc(this->byteLength);
HXDLIN(  37)			this->buffer = this1;
HXLINE(  38)			this->length = ( (int)(elements) );
            		}
            	}

Dynamic ArrayBufferView_obj::__CreateEmpty() { return new ArrayBufferView_obj; }

void *ArrayBufferView_obj::_hx_vtable = 0;

Dynamic ArrayBufferView_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ArrayBufferView_obj > _hx_result = new ArrayBufferView_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ArrayBufferView_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x24c8740e;
}

void ArrayBufferView_obj::copyFromArray(::Array< Float > array,::hx::Null< int >  __o_offset){
            		int offset = __o_offset.Default(0);
            	HX_STACKFRAME(&_hx_pos_244a612994c6bd06_279_copyFromArray)
HXLINE( 281)		int i = 0;
HXDLIN( 281)		int len = array->length;
HXLINE( 283)		switch((int)(this->type)){
            			case (int)0: {
HXLINE( 392)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("copyFromArray on a base type ArrayBuffer",e8,01,1a,e2)));
            			}
            			break;
            			case (int)1: {
HXLINE( 286)				while((i < len)){
HXLINE( 288)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 294)					{
HXLINE( 294)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 294)						int value = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 294)						 ::__hxcpp_memory_set_byte(buffer->b,pos,value);
            					}
HXLINE( 296)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 299)				while((i < len)){
HXLINE( 301)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 307)					 ::haxe::io::Bytes _hx_tmp = this->buffer;
HXDLIN( 307)					::lime::utils::ArrayBufferIO_obj::setInt16(_hx_tmp,pos,::Std_obj::_hx_int(array->__get(i)));
HXLINE( 309)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 312)				while((i < len)){
HXLINE( 314)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 320)					{
HXLINE( 320)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 320)						int value = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 320)						 ::__hxcpp_memory_set_i32(buffer->b,pos,value);
            					}
HXLINE( 322)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)4: {
HXLINE( 325)				while((i < len)){
HXLINE( 327)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 333)					{
HXLINE( 333)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 333)						int value = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 333)						 ::__hxcpp_memory_set_byte(buffer->b,pos,value);
            					}
HXLINE( 335)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)5: {
HXLINE( 364)				while((i < len)){
HXLINE( 366)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 372)					{
HXLINE( 372)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 372)						{
HXLINE( 372)							int _hx_int = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 372)							Float _out;
HXDLIN( 372)							if ((_hx_int < 0)) {
HXLINE( 372)								_out = (((Float)4294967296.0) + _hx_int);
            							}
            							else {
HXLINE( 372)								_out = (_hx_int + ((Float)0.0));
            							}
HXDLIN( 372)							int _out1 = ::Std_obj::_hx_int(_out);
HXDLIN( 372)							if ((_out1 > 255)) {
HXLINE( 372)								_out1 = 255;
            							}
HXDLIN( 372)							int value;
HXDLIN( 372)							if ((_out1 < 0)) {
HXLINE( 372)								value = 0;
            							}
            							else {
HXLINE( 372)								value = _out1;
            							}
HXDLIN( 372)							 ::__hxcpp_memory_set_byte(buffer->b,pos,value);
            						}
            					}
HXLINE( 374)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)6: {
HXLINE( 338)				while((i < len)){
HXLINE( 340)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 346)					{
HXLINE( 346)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 346)						int value = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 346)						 ::__hxcpp_memory_set_ui16(buffer->b,pos,value);
            					}
HXLINE( 348)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)7: {
HXLINE( 351)				while((i < len)){
HXLINE( 353)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 359)					{
HXLINE( 359)						 ::haxe::io::Bytes buffer = this->buffer;
HXDLIN( 359)						int value = ::Std_obj::_hx_int(array->__get(i));
HXDLIN( 359)						 ::__hxcpp_memory_set_ui32(buffer->b,pos,value);
            					}
HXLINE( 361)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)8: {
HXLINE( 377)				while((i < len)){
HXLINE( 379)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 380)					 ::__hxcpp_memory_set_float(this->buffer->b,pos,array->__get(i));
HXLINE( 381)					i = (i + 1);
            				}
            			}
            			break;
            			case (int)9: {
HXLINE( 384)				while((i < len)){
HXLINE( 386)					int pos = ((offset + i) * this->bytesPerElement);
HXLINE( 387)					 ::__hxcpp_memory_set_double(this->buffer->b,pos,array->__get(i));
HXLINE( 388)					i = (i + 1);
            				}
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(ArrayBufferView_obj,copyFromArray,(void))


::hx::ObjectPtr< ArrayBufferView_obj > ArrayBufferView_obj::__new( ::Dynamic elements,int in_type) {
	::hx::ObjectPtr< ArrayBufferView_obj > __this = new ArrayBufferView_obj();
	__this->__construct(elements,in_type);
	return __this;
}

::hx::ObjectPtr< ArrayBufferView_obj > ArrayBufferView_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic elements,int in_type) {
	ArrayBufferView_obj *__this = (ArrayBufferView_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ArrayBufferView_obj), true, "lime.utils.ArrayBufferView"));
	*(void **)__this = ArrayBufferView_obj::_hx_vtable;
	__this->__construct(elements,in_type);
	return __this;
}

ArrayBufferView_obj::ArrayBufferView_obj()
{
}

void ArrayBufferView_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ArrayBufferView);
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(byteOffset,"byteOffset");
	HX_MARK_MEMBER_NAME(byteLength,"byteLength");
	HX_MARK_MEMBER_NAME(length,"length");
	HX_MARK_MEMBER_NAME(bytesPerElement,"bytesPerElement");
	HX_MARK_END_CLASS();
}

void ArrayBufferView_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(byteOffset,"byteOffset");
	HX_VISIT_MEMBER_NAME(byteLength,"byteLength");
	HX_VISIT_MEMBER_NAME(length,"length");
	HX_VISIT_MEMBER_NAME(bytesPerElement,"bytesPerElement");
}

::hx::Val ArrayBufferView_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { return ::hx::Val( buffer ); }
		if (HX_FIELD_EQ(inName,"length") ) { return ::hx::Val( length ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"byteOffset") ) { return ::hx::Val( byteOffset ); }
		if (HX_FIELD_EQ(inName,"byteLength") ) { return ::hx::Val( byteLength ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"copyFromArray") ) { return ::hx::Val( copyFromArray_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"bytesPerElement") ) { return ::hx::Val( bytesPerElement ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ArrayBufferView_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast<  ::haxe::io::Bytes >(); return inValue; }
		if (HX_FIELD_EQ(inName,"length") ) { length=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"byteOffset") ) { byteOffset=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"byteLength") ) { byteLength=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"bytesPerElement") ) { bytesPerElement=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ArrayBufferView_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("buffer",00,bd,94,d0));
	outFields->push(HX_("byteOffset",bb,20,44,38));
	outFields->push(HX_("byteLength",0e,1e,0c,77));
	outFields->push(HX_("length",e6,94,07,9f));
	outFields->push(HX_("bytesPerElement",aa,67,89,18));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ArrayBufferView_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(ArrayBufferView_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsObject /*  ::haxe::io::Bytes */ ,(int)offsetof(ArrayBufferView_obj,buffer),HX_("buffer",00,bd,94,d0)},
	{::hx::fsInt,(int)offsetof(ArrayBufferView_obj,byteOffset),HX_("byteOffset",bb,20,44,38)},
	{::hx::fsInt,(int)offsetof(ArrayBufferView_obj,byteLength),HX_("byteLength",0e,1e,0c,77)},
	{::hx::fsInt,(int)offsetof(ArrayBufferView_obj,length),HX_("length",e6,94,07,9f)},
	{::hx::fsInt,(int)offsetof(ArrayBufferView_obj,bytesPerElement),HX_("bytesPerElement",aa,67,89,18)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ArrayBufferView_obj_sStaticStorageInfo = 0;
#endif

static ::String ArrayBufferView_obj_sMemberFields[] = {
	HX_("type",ba,f2,08,4d),
	HX_("buffer",00,bd,94,d0),
	HX_("byteOffset",bb,20,44,38),
	HX_("byteLength",0e,1e,0c,77),
	HX_("length",e6,94,07,9f),
	HX_("bytesPerElement",aa,67,89,18),
	HX_("copyFromArray",5a,dd,dd,3b),
	::String(null()) };

::hx::Class ArrayBufferView_obj::__mClass;

void ArrayBufferView_obj::__register()
{
	ArrayBufferView_obj _hx_dummy;
	ArrayBufferView_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("lime.utils.ArrayBufferView",08,da,61,c9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ArrayBufferView_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ArrayBufferView_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ArrayBufferView_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ArrayBufferView_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace lime
} // end namespace utils
