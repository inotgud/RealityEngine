// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_math__RGBA_RGBA_Impl_
#include <lime/math/_RGBA/RGBA_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IntVector
#include <openfl/_Vector/IntVector.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7fcfbbd74e9c398a_51___init__,"::lime::math::_RGBA::RGBA_Impl__obj","__init__",0x1ae221dc,"::lime::math::_RGBA::RGBA_Impl__obj.__init__","lime/math/RGBA.hx",51,0x0518ba7d)
namespace lime{
namespace math{
namespace _RGBA{

void RGBA_Impl__obj::__construct() { }

Dynamic RGBA_Impl__obj::__CreateEmpty() { return new RGBA_Impl__obj; }

void *RGBA_Impl__obj::_hx_vtable = 0;

Dynamic RGBA_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RGBA_Impl__obj > _hx_result = new RGBA_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RGBA_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4bfe0b6a;
}

void RGBA_Impl__obj::__init__(){
            	HX_GC_STACKFRAME(&_hx_pos_7fcfbbd74e9c398a_51___init__)
HXLINE(  55)		 ::haxe::io::Bytes buffer = null();
HXDLIN(  55)		::cpp::VirtualArray array = null();
HXDLIN(  55)		 ::openfl::_Vector::IntVector vector = null();
HXDLIN(  55)		 ::lime::utils::ArrayBufferView view = null();
HXDLIN(  55)		 ::Dynamic len = null();
HXDLIN(  55)		 ::lime::utils::ArrayBufferView this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,256,7);
HXDLIN(  55)		::lime::math::_RGBA::RGBA_Impl__obj::_hx___alpha16 = this1;
HXLINE(  57)		{
HXLINE(  57)			int _g = 0;
HXDLIN(  57)			while((_g < 256)){
HXLINE(  57)				_g = (_g + 1);
HXDLIN(  57)				int i = (_g - 1);
HXLINE(  59)				{
HXLINE(  59)					 ::lime::utils::ArrayBufferView this1 = ::lime::math::_RGBA::RGBA_Impl__obj::_hx___alpha16;
HXDLIN(  59)					int val = ::Math_obj::ceil((( (Float)(i) ) * ((Float)257.00392156862745)));
HXDLIN(  59)					 ::__hxcpp_memory_set_ui32(this1->buffer->b,(this1->byteOffset + (i * 4)),val);
            				}
            			}
            		}
HXLINE(  62)		 ::haxe::io::Bytes buffer1 = null();
HXDLIN(  62)		::cpp::VirtualArray array1 = null();
HXDLIN(  62)		 ::openfl::_Vector::IntVector vector1 = null();
HXDLIN(  62)		 ::lime::utils::ArrayBufferView view1 = null();
HXDLIN(  62)		 ::Dynamic len1 = null();
HXDLIN(  62)		 ::lime::utils::ArrayBufferView this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,511,4);
HXDLIN(  62)		::lime::math::_RGBA::RGBA_Impl__obj::_hx___clamp = this2;
HXLINE(  64)		{
HXLINE(  64)			int _g1 = 0;
HXDLIN(  64)			while((_g1 < 255)){
HXLINE(  64)				_g1 = (_g1 + 1);
HXDLIN(  64)				int i = (_g1 - 1);
HXLINE(  66)				{
HXLINE(  66)					 ::lime::utils::ArrayBufferView this1 = ::lime::math::_RGBA::RGBA_Impl__obj::_hx___clamp;
HXDLIN(  66)					 ::__hxcpp_memory_set_byte(this1->buffer->b,(this1->byteOffset + i),i);
            				}
            			}
            		}
HXLINE(  69)		{
HXLINE(  69)			int _g2 = 255;
HXDLIN(  69)			int _g3 = 511;
HXDLIN(  69)			while((_g2 < _g3)){
HXLINE(  69)				_g2 = (_g2 + 1);
HXDLIN(  69)				int i = (_g2 - 1);
HXLINE(  71)				{
HXLINE(  71)					 ::lime::utils::ArrayBufferView this1 = ::lime::math::_RGBA::RGBA_Impl__obj::_hx___clamp;
HXDLIN(  71)					 ::__hxcpp_memory_set_byte(this1->buffer->b,(this1->byteOffset + i),255);
            				}
            			}
            		}
            	}


 ::lime::utils::ArrayBufferView RGBA_Impl__obj::_hx___alpha16;

 ::lime::utils::ArrayBufferView RGBA_Impl__obj::_hx___clamp;

int RGBA_Impl__obj::a16;

Float RGBA_Impl__obj::unmult;


RGBA_Impl__obj::RGBA_Impl__obj()
{
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *RGBA_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo RGBA_Impl__obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(void *) &RGBA_Impl__obj::_hx___alpha16,HX_("__alpha16",a3,36,64,33)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(void *) &RGBA_Impl__obj::_hx___clamp,HX_("__clamp",db,cb,b6,b2)},
	{::hx::fsInt,(void *) &RGBA_Impl__obj::a16,HX_("a16",86,c5,49,00)},
	{::hx::fsFloat,(void *) &RGBA_Impl__obj::unmult,HX_("unmult",c9,6e,3a,66)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void RGBA_Impl__obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(RGBA_Impl__obj::_hx___alpha16,"__alpha16");
	HX_MARK_MEMBER_NAME(RGBA_Impl__obj::_hx___clamp,"__clamp");
	HX_MARK_MEMBER_NAME(RGBA_Impl__obj::a16,"a16");
	HX_MARK_MEMBER_NAME(RGBA_Impl__obj::unmult,"unmult");
};

#ifdef HXCPP_VISIT_ALLOCS
static void RGBA_Impl__obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(RGBA_Impl__obj::_hx___alpha16,"__alpha16");
	HX_VISIT_MEMBER_NAME(RGBA_Impl__obj::_hx___clamp,"__clamp");
	HX_VISIT_MEMBER_NAME(RGBA_Impl__obj::a16,"a16");
	HX_VISIT_MEMBER_NAME(RGBA_Impl__obj::unmult,"unmult");
};

#endif

::hx::Class RGBA_Impl__obj::__mClass;

static ::String RGBA_Impl__obj_sStaticFields[] = {
	HX_("__alpha16",a3,36,64,33),
	HX_("__clamp",db,cb,b6,b2),
	HX_("a16",86,c5,49,00),
	HX_("unmult",c9,6e,3a,66),
	::String(null())
};

void RGBA_Impl__obj::__register()
{
	RGBA_Impl__obj _hx_dummy;
	RGBA_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("lime.math._RGBA.RGBA_Impl_",9c,7d,b4,a6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = RGBA_Impl__obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(RGBA_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< RGBA_Impl__obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = RGBA_Impl__obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RGBA_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RGBA_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void RGBA_Impl__obj::__boot()
{
}

} // end namespace lime
} // end namespace math
} // end namespace _RGBA
