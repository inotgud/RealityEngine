// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Alphabet
#include <Alphabet.h>
#endif
#ifndef INCLUDED_Controls
#include <Controls.h>
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_MusicBeatSubstate
#include <MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PlayerSettings
#include <PlayerSettings.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxAction
#include <flixel/input/actions/FlxAction.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionDigital
#include <flixel/input/actions/FlxActionDigital.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionSet
#include <flixel/input/actions/FlxActionSet.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSoundGroup
#include <flixel/system/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_openfl_Lib
#include <openfl/Lib.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_MovieClip
#include <openfl/display/MovieClip.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_options_Question
#include <options/Question.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5816709551bda8ab_32_new,"options.Question","new",0x27bb2a48,"options.Question.new","options/Question.hx",32,0x85a823c7)
static const ::String _hx_array_data_893ea656_1[] = {
	HX_("On",3f,45,00,00),HX_("Off",4f,4b,3c,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_57_optionEnter,"options.Question","optionEnter",0x918ce34b,"options.Question.optionEnter","options/Question.hx",57,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_149_create,"options.Question","create",0x1c5f2e14,"options.Question.create","options/Question.hx",149,0x85a823c7)
static const ::String _hx_array_data_893ea656_6[] = {
	HX_("Down Scroll",0b,74,eb,eb),HX_("Up Scroll",32,ef,e1,be),
};
static const ::String _hx_array_data_893ea656_7[] = {
	HX_("Enabled",61,2c,82,4b),HX_("Disabled",9c,fd,b5,55),
};
static const ::String _hx_array_data_893ea656_8[] = {
	HX_("Bf",e4,39,00,00),HX_("Dad",27,ee,33,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_199_update,"options.Question","update",0x27554d21,"options.Question.update","options/Question.hx",199,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_242_changeSelection,"options.Question","changeSelection",0x90b02ea4,"options.Question.changeSelection","options/Question.hx",242,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_41_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",41,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_42_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",42,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_43_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",43,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_44_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",44,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_45_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",45,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_46_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",46,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_47_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",47,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_48_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",48,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_49_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",49,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_50_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",50,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_51_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",51,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_52_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",52,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_53_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",53,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_54_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",54,0x85a823c7)
HX_LOCAL_STACK_FRAME(_hx_pos_5816709551bda8ab_55_boot,"options.Question","boot",0x9422d54a,"options.Question.boot","options/Question.hx",55,0x85a823c7)
namespace options{

void Question_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_32_new)
HXLINE(  36)		this->options = ::Array_obj< ::String >::fromData( _hx_array_data_893ea656_1,2);
HXLINE(  32)		super::__construct();
            	}

Dynamic Question_obj::__CreateEmpty() { return new Question_obj; }

void *Question_obj::_hx_vtable = 0;

Dynamic Question_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Question_obj > _hx_result = new Question_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Question_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x5661ffbf) {
			if (inClassId<=(int)0x56155424) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x56155424;
			} else {
				return inClassId==(int)0x5661ffbf;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		if (inClassId<=(int)0x7ccf8994) {
			return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
		} else {
			return inClassId==(int)0x7fce3ab0;
		}
	}
}

void Question_obj::optionEnter(::String label){
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_57_optionEnter)
HXDLIN(  57)		::String _hx_switch_0 = label;
            		if (  (_hx_switch_0==HX_("Bf",e4,39,00,00)) ){
HXLINE( 137)			::flixel::FlxG_obj::save->data->__SetField(HX_("abfd",5f,68,68,40),HX_("Bf",e4,39,00,00),::hx::paccDynamic);
HXLINE( 138)			this->close();
HXLINE( 136)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("Dad",27,ee,33,00)) ){
HXLINE( 140)			::flixel::FlxG_obj::save->data->__SetField(HX_("abfd",5f,68,68,40),HX_("Dad",27,ee,33,00),::hx::paccDynamic);
HXLINE( 141)			this->close();
HXLINE( 139)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("Down Scroll",0b,74,eb,eb)) ){
HXLINE( 133)			::flixel::FlxG_obj::save->data->__SetField(HX_("downscroll",ef,45,d4,4f),HX_("Downscroll",0f,4a,85,46),::hx::paccDynamic);
HXDLIN( 133)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("Off",4f,4b,3c,00)) ){
HXLINE(  96)			if (::options::Question_obj::isBotPlay) {
HXLINE(  98)				::flixel::FlxG_obj::save->data->__SetField(HX_("botplay",7b,fb,a9,61),HX_("off",6f,93,54,00),::hx::paccDynamic);
            			}
HXLINE( 100)			if (::options::Question_obj::isTap) {
HXLINE( 102)				::flixel::FlxG_obj::save->data->__SetField(HX_("ghost",4f,8f,58,93),HX_("Disabled",9c,fd,b5,55),::hx::paccDynamic);
            			}
HXLINE( 104)			if (::options::Question_obj::isFPS) {
HXLINE( 106)				::flixel::FlxG_obj::save->data->__SetField(HX_("fps",e9,c7,4d,00),HX_("off",6f,93,54,00),::hx::paccDynamic);
HXLINE( 107)				::hx::TCast<  ::Main >::cast(::openfl::Lib_obj::get_current()->getChildAt(0))->toggleFPS(( (bool)(::flixel::FlxG_obj::save->data->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic)) ));
            			}
HXLINE( 109)			if (::options::Question_obj::isFlashing) {
HXLINE( 111)				::flixel::FlxG_obj::save->data->__SetField(HX_("flashing",32,85,e8,99),HX_("off",6f,93,54,00),::hx::paccDynamic);
            			}
HXLINE( 113)			if (::options::Question_obj::isWatermark) {
HXLINE( 115)				::Main_obj::watermarks = !(::Main_obj::watermarks);
HXLINE( 116)				::flixel::FlxG_obj::save->data->__SetField(HX_("watermark",a4,af,1e,e0),HX_("off",6f,93,54,00),::hx::paccDynamic);
HXLINE( 117)				::Main_obj::watermarks = ( (bool)(::flixel::FlxG_obj::save->data->__Field(HX_("watermark",a4,af,1e,e0),::hx::paccDynamic)) );
            			}
HXLINE( 119)			if (::options::Question_obj::isColored) {
HXLINE( 121)				::flixel::FlxG_obj::save->data->__SetField(HX_("coloredmenubg",26,f7,c7,fd),HX_("Off",4f,4b,3c,00),::hx::paccDynamic);
            			}
HXLINE( 123)			if (::options::Question_obj::isAntialiasing) {
HXLINE( 125)				::flixel::FlxG_obj::save->data->__SetField(HX_("antialiasing",f4,16,b3,48),HX_("off",6f,93,54,00),::hx::paccDynamic);
            			}
HXLINE( 127)			if (::options::Question_obj::isSystemCursor) {
HXLINE( 129)				::flixel::FlxG_obj::save->data->__SetField(HX_("systemCursorData",ef,6f,d5,d8),false,::hx::paccDynamic);
HXLINE( 130)				::flixel::FlxG_obj::mouse->set_useSystemCursor(false);
            			}
HXLINE(  95)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("On",3f,45,00,00)) ){
HXLINE(  59)			if (::options::Question_obj::isBotPlay) {
HXLINE(  61)				::flixel::FlxG_obj::save->data->__SetField(HX_("botplay",7b,fb,a9,61),HX_("on",1f,61,00,00),::hx::paccDynamic);
            			}
HXLINE(  63)			if (::options::Question_obj::isTap) {
HXLINE(  65)				::flixel::FlxG_obj::save->data->__SetField(HX_("ghost",4f,8f,58,93),HX_("Enabled",61,2c,82,4b),::hx::paccDynamic);
            			}
HXLINE(  67)			bool _hx_tmp = ::options::Question_obj::isFPS;
HXLINE(  71)			if (::options::Question_obj::isFlashing) {
HXLINE(  73)				::flixel::FlxG_obj::save->data->__SetField(HX_("flashing",32,85,e8,99),HX_("on",1f,61,00,00),::hx::paccDynamic);
            			}
HXLINE(  75)			if (::options::Question_obj::isWatermark) {
HXLINE(  77)				::Main_obj::watermarks = !(::Main_obj::watermarks);
HXLINE(  78)				::flixel::FlxG_obj::save->data->__SetField(HX_("watermark",a4,af,1e,e0),HX_("on",1f,61,00,00),::hx::paccDynamic);
HXLINE(  79)				::Main_obj::watermarks = ( (bool)(::flixel::FlxG_obj::save->data->__Field(HX_("watermark",a4,af,1e,e0),::hx::paccDynamic)) );
            			}
HXLINE(  81)			if (::options::Question_obj::isColored) {
HXLINE(  83)				::flixel::FlxG_obj::save->data->__SetField(HX_("coloredmenubg",26,f7,c7,fd),HX_("On",3f,45,00,00),::hx::paccDynamic);
            			}
HXLINE(  85)			if (::options::Question_obj::isAntialiasing) {
HXLINE(  87)				::flixel::FlxG_obj::save->data->__SetField(HX_("antialiasing",f4,16,b3,48),HX_("on",1f,61,00,00),::hx::paccDynamic);
            			}
HXLINE(  89)			if (::options::Question_obj::isSystemCursor) {
HXLINE(  91)				::flixel::FlxG_obj::save->data->__SetField(HX_("systemCursorData",ef,6f,d5,d8),true,::hx::paccDynamic);
HXLINE(  92)				::flixel::FlxG_obj::mouse->set_useSystemCursor(true);
            			}
HXLINE(  58)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("Up Scroll",32,ef,e1,be)) ){
HXLINE( 135)			::flixel::FlxG_obj::save->data->__SetField(HX_("downscroll",ef,45,d4,4f),HX_("Upscroll",c8,b0,88,76),::hx::paccDynamic);
HXDLIN( 135)			goto _hx_goto_2;
            		}
            		_hx_goto_2:;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Question_obj,optionEnter,(void))

void Question_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_5816709551bda8ab_149_create)
HXLINE( 150)		if ((::options::Question_obj::isScrollSpeed == true)) {
HXLINE( 152)			this->options = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(::options::Question_obj::scrollInt));
            		}
HXLINE( 154)		if ((::options::Question_obj::isScroll == true)) {
HXLINE( 156)			this->options = ::Array_obj< ::String >::fromData( _hx_array_data_893ea656_6,2);
            		}
HXLINE( 158)		if ((::options::Question_obj::isTap == true)) {
HXLINE( 160)			this->options = ::Array_obj< ::String >::fromData( _hx_array_data_893ea656_7,2);
            		}
HXLINE( 162)		if ((::options::Question_obj::isMidSongEvent == true)) {
HXLINE( 164)			this->options = ::Array_obj< ::String >::fromData( _hx_array_data_893ea656_8,2);
            		}
HXLINE( 167)		this->blackBox =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,0,null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE( 168)		this->add(this->blackBox);
HXLINE( 170)		::flixel::tweens::FlxTween_obj::tween(this->blackBox, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),((Float)0.7))),1, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::expoInOut_dyn())));
HXLINE( 172)		this->blackBox->set_alpha(((Float)0.6));
HXLINE( 174)		this->grpOptions =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 175)		this->add(this->grpOptions);
HXLINE( 179)		{
HXLINE( 179)			int _g = 0;
HXDLIN( 179)			int _g1 = this->options->length;
HXDLIN( 179)			while((_g < _g1)){
HXLINE( 179)				_g = (_g + 1);
HXDLIN( 179)				int i = (_g - 1);
HXLINE( 181)				this->optionText =  ::Alphabet_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)((70 * i)) ),this->options->__get(i),true,false,null(),null(),null());
HXLINE( 182)				this->optionText->isMenuItem = true;
HXLINE( 183)				{
HXLINE( 183)					 ::Alphabet _this = this->optionText;
HXDLIN( 183)					 ::flixel::util::FlxAxes axes = ::flixel::util::FlxAxes_obj::XY_dyn();
HXDLIN( 183)					bool _hx_tmp;
HXDLIN( 183)					switch((int)(axes->_hx_getIndex())){
            						case (int)0: case (int)2: {
HXLINE( 183)							_hx_tmp = true;
            						}
            						break;
            						default:{
HXLINE( 183)							_hx_tmp = false;
            						}
            					}
HXDLIN( 183)					if (_hx_tmp) {
HXLINE( 183)						int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN( 183)						_this->set_x(((( (Float)(_hx_tmp) ) - _this->get_width()) / ( (Float)(2) )));
            					}
HXDLIN( 183)					bool _hx_tmp1;
HXDLIN( 183)					switch((int)(axes->_hx_getIndex())){
            						case (int)1: case (int)2: {
HXLINE( 183)							_hx_tmp1 = true;
            						}
            						break;
            						default:{
HXLINE( 183)							_hx_tmp1 = false;
            						}
            					}
HXDLIN( 183)					if (_hx_tmp1) {
HXLINE( 183)						int _hx_tmp = ::flixel::FlxG_obj::height;
HXDLIN( 183)						_this->set_y(((( (Float)(_hx_tmp) ) - _this->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE( 184)				this->optionText->targetY = ( (Float)(i) );
HXLINE( 185)				{
HXLINE( 185)					 ::Alphabet _g1 = this->optionText;
HXDLIN( 185)					_g1->set_y((_g1->y + ((( (Float)(100) ) * (( (Float)(i) ) - (( (Float)(this->options->length) ) / ( (Float)(2) )))) + 50)));
            				}
HXLINE( 186)				this->grpOptions->add(this->optionText).StaticCast<  ::Alphabet >();
            			}
            		}
HXLINE( 190)		this->selectorLeft =  ::Alphabet_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),HX_(">",3e,00,00,00),true,false,null(),null(),null());
HXLINE( 191)		this->add(this->selectorLeft);
HXLINE( 192)		this->selectorRight =  ::Alphabet_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),HX_("<",3c,00,00,00),true,false,null(),null(),null());
HXLINE( 193)		this->add(this->selectorRight);
HXLINE( 196)		this->super::create();
            	}


void Question_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_199_update)
HXLINE( 200)		this->super::update(elapsed);
HXLINE( 201)		if (::options::Question_obj::isScrollSpeed) {
HXLINE( 203)			if (::PlayerSettings_obj::player1->controls->_right->check()) {
HXLINE( 206)				this->remove(this->optionText,null());
HXLINE( 207)				this->options = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(::options::Question_obj::scrollInt));
HXLINE( 208)				this->add(this->optionText);
            			}
HXLINE( 210)			if (::PlayerSettings_obj::player1->controls->_left->check()) {
HXLINE( 213)				this->remove(this->optionText,null());
HXLINE( 214)				this->options = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(::options::Question_obj::scrollInt));
HXLINE( 215)				this->add(this->optionText);
            			}
            		}
HXLINE( 218)		if (::PlayerSettings_obj::player1->controls->_back->check()) {
HXLINE( 220)			this->close();
            		}
HXLINE( 222)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 222)		if (_this->keyManager->checkStatusUnsafe(38,_this->status)) {
HXLINE( 224)			this->changeSelection(-1);
            		}
HXLINE( 226)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 226)		if (_this1->keyManager->checkStatusUnsafe(40,_this1->status)) {
HXLINE( 228)			this->changeSelection(1);
            		}
HXLINE( 230)		if (::PlayerSettings_obj::player1->controls->_accept->check()) {
HXLINE( 232)			if (::options::Question_obj::isScrollSpeed) {
HXLINE( 234)				::flixel::FlxG_obj::save->data->__SetField(HX_("scrollSpeed",3a,e0,46,cb),::options::Question_obj::scrollInt,::hx::paccDynamic);
            			}
            			else {
HXLINE( 237)				this->optionEnter(this->options->__get(::options::Question_obj::curSelected));
            			}
            		}
            	}


void Question_obj::changeSelection(::hx::Null< int >  __o_huh){
            		int huh = __o_huh.Default(0);
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_242_changeSelection)
HXLINE( 243)		 ::Dynamic _hx_tmp = ::hx::ClassOf< ::options::Question >();
HXDLIN( 243)		::options::Question_obj::curSelected = (::options::Question_obj::curSelected + huh);
HXLINE( 244)		if ((::options::Question_obj::curSelected < 0)) {
HXLINE( 245)			::options::Question_obj::curSelected = (this->options->length - 1);
            		}
HXLINE( 246)		if ((::options::Question_obj::curSelected >= this->options->length)) {
HXLINE( 247)			::options::Question_obj::curSelected = 0;
            		}
HXLINE( 249)		int bullShit = 0;
HXLINE( 251)		{
HXLINE( 251)			int _g = 0;
HXDLIN( 251)			::Array< ::Dynamic> _g1 = this->grpOptions->members;
HXDLIN( 251)			while((_g < _g1->length)){
HXLINE( 251)				 ::Alphabet item = _g1->__get(_g).StaticCast<  ::Alphabet >();
HXDLIN( 251)				_g = (_g + 1);
HXLINE( 253)				item->targetY = ( (Float)((bullShit - ::options::Question_obj::curSelected)) );
HXLINE( 254)				bullShit = (bullShit + 1);
HXLINE( 256)				item->set_alpha(((Float)0.6));
HXLINE( 259)				if ((item->targetY == 0)) {
HXLINE( 261)					item->set_alpha(( (Float)(1) ));
            				}
            			}
            		}
HXLINE( 265)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 265)		_hx_tmp1->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(Question_obj,changeSelection,(void))

bool Question_obj::isScroll;

bool Question_obj::isRedesigned;

bool Question_obj::isTap;

bool Question_obj::isColored;

bool Question_obj::isScrollSpeed;

int Question_obj::scrollInt;

bool Question_obj::isBotPlay;

int Question_obj::curSelected;

bool Question_obj::isFPS;

bool Question_obj::isFlashing;

bool Question_obj::isWatermark;

bool Question_obj::isMenuSong;

bool Question_obj::isAntialiasing;

bool Question_obj::isMidSongEvent;

bool Question_obj::isSystemCursor;


::hx::ObjectPtr< Question_obj > Question_obj::__new() {
	::hx::ObjectPtr< Question_obj > __this = new Question_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Question_obj > Question_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Question_obj *__this = (Question_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Question_obj), true, "options.Question"));
	*(void **)__this = Question_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Question_obj::Question_obj()
{
}

void Question_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Question);
	HX_MARK_MEMBER_NAME(grpOptions,"grpOptions");
	HX_MARK_MEMBER_NAME(blackBox,"blackBox");
	HX_MARK_MEMBER_NAME(options,"options");
	HX_MARK_MEMBER_NAME(optionTextin,"optionTextin");
	HX_MARK_MEMBER_NAME(onSaveData,"onSaveData");
	HX_MARK_MEMBER_NAME(onSaveItem,"onSaveItem");
	HX_MARK_MEMBER_NAME(optionText,"optionText");
	HX_MARK_MEMBER_NAME(selectorLeft,"selectorLeft");
	HX_MARK_MEMBER_NAME(selectorRight,"selectorRight");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Question_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(grpOptions,"grpOptions");
	HX_VISIT_MEMBER_NAME(blackBox,"blackBox");
	HX_VISIT_MEMBER_NAME(options,"options");
	HX_VISIT_MEMBER_NAME(optionTextin,"optionTextin");
	HX_VISIT_MEMBER_NAME(onSaveData,"onSaveData");
	HX_VISIT_MEMBER_NAME(onSaveItem,"onSaveItem");
	HX_VISIT_MEMBER_NAME(optionText,"optionText");
	HX_VISIT_MEMBER_NAME(selectorLeft,"selectorLeft");
	HX_VISIT_MEMBER_NAME(selectorRight,"selectorRight");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Question_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"options") ) { return ::hx::Val( options ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"blackBox") ) { return ::hx::Val( blackBox ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"grpOptions") ) { return ::hx::Val( grpOptions ); }
		if (HX_FIELD_EQ(inName,"onSaveData") ) { return ::hx::Val( onSaveData ); }
		if (HX_FIELD_EQ(inName,"onSaveItem") ) { return ::hx::Val( onSaveItem ); }
		if (HX_FIELD_EQ(inName,"optionText") ) { return ::hx::Val( optionText ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"optionEnter") ) { return ::hx::Val( optionEnter_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"optionTextin") ) { return ::hx::Val( optionTextin ); }
		if (HX_FIELD_EQ(inName,"selectorLeft") ) { return ::hx::Val( selectorLeft ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"selectorRight") ) { return ::hx::Val( selectorRight ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"changeSelection") ) { return ::hx::Val( changeSelection_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Question_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"isTap") ) { outValue = ( isTap ); return true; }
		if (HX_FIELD_EQ(inName,"isFPS") ) { outValue = ( isFPS ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isScroll") ) { outValue = ( isScroll ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isColored") ) { outValue = ( isColored ); return true; }
		if (HX_FIELD_EQ(inName,"scrollInt") ) { outValue = ( scrollInt ); return true; }
		if (HX_FIELD_EQ(inName,"isBotPlay") ) { outValue = ( isBotPlay ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"isFlashing") ) { outValue = ( isFlashing ); return true; }
		if (HX_FIELD_EQ(inName,"isMenuSong") ) { outValue = ( isMenuSong ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { outValue = ( curSelected ); return true; }
		if (HX_FIELD_EQ(inName,"isWatermark") ) { outValue = ( isWatermark ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"isRedesigned") ) { outValue = ( isRedesigned ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"isScrollSpeed") ) { outValue = ( isScrollSpeed ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"isAntialiasing") ) { outValue = ( isAntialiasing ); return true; }
		if (HX_FIELD_EQ(inName,"isMidSongEvent") ) { outValue = ( isMidSongEvent ); return true; }
		if (HX_FIELD_EQ(inName,"isSystemCursor") ) { outValue = ( isSystemCursor ); return true; }
	}
	return false;
}

::hx::Val Question_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"options") ) { options=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"blackBox") ) { blackBox=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"grpOptions") ) { grpOptions=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"onSaveData") ) { onSaveData=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"onSaveItem") ) { onSaveItem=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"optionText") ) { optionText=inValue.Cast<  ::Alphabet >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"optionTextin") ) { optionTextin=inValue.Cast<  ::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"selectorLeft") ) { selectorLeft=inValue.Cast<  ::Alphabet >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"selectorRight") ) { selectorRight=inValue.Cast<  ::Alphabet >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Question_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"isTap") ) { isTap=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"isFPS") ) { isFPS=ioValue.Cast< bool >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isScroll") ) { isScroll=ioValue.Cast< bool >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isColored") ) { isColored=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"scrollInt") ) { scrollInt=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"isBotPlay") ) { isBotPlay=ioValue.Cast< bool >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"isFlashing") ) { isFlashing=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"isMenuSong") ) { isMenuSong=ioValue.Cast< bool >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { curSelected=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"isWatermark") ) { isWatermark=ioValue.Cast< bool >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"isRedesigned") ) { isRedesigned=ioValue.Cast< bool >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"isScrollSpeed") ) { isScrollSpeed=ioValue.Cast< bool >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"isAntialiasing") ) { isAntialiasing=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"isMidSongEvent") ) { isMidSongEvent=ioValue.Cast< bool >(); return true; }
		if (HX_FIELD_EQ(inName,"isSystemCursor") ) { isSystemCursor=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void Question_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("grpOptions",f9,45,d8,00));
	outFields->push(HX_("blackBox",8c,81,93,80));
	outFields->push(HX_("options",5e,33,fe,df));
	outFields->push(HX_("optionTextin",27,3b,47,42));
	outFields->push(HX_("onSaveData",46,c4,d3,d3));
	outFields->push(HX_("onSaveItem",2f,33,30,d7));
	outFields->push(HX_("optionText",c2,2a,95,92));
	outFields->push(HX_("selectorLeft",c6,e2,77,e7));
	outFields->push(HX_("selectorRight",3d,98,7b,18));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Question_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(Question_obj,grpOptions),HX_("grpOptions",f9,45,d8,00)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Question_obj,blackBox),HX_("blackBox",8c,81,93,80)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Question_obj,options),HX_("options",5e,33,fe,df)},
	{::hx::fsObject /*  ::Alphabet */ ,(int)offsetof(Question_obj,optionTextin),HX_("optionTextin",27,3b,47,42)},
	{::hx::fsString,(int)offsetof(Question_obj,onSaveData),HX_("onSaveData",46,c4,d3,d3)},
	{::hx::fsString,(int)offsetof(Question_obj,onSaveItem),HX_("onSaveItem",2f,33,30,d7)},
	{::hx::fsObject /*  ::Alphabet */ ,(int)offsetof(Question_obj,optionText),HX_("optionText",c2,2a,95,92)},
	{::hx::fsObject /*  ::Alphabet */ ,(int)offsetof(Question_obj,selectorLeft),HX_("selectorLeft",c6,e2,77,e7)},
	{::hx::fsObject /*  ::Alphabet */ ,(int)offsetof(Question_obj,selectorRight),HX_("selectorRight",3d,98,7b,18)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Question_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &Question_obj::isScroll,HX_("isScroll",97,73,ce,9f)},
	{::hx::fsBool,(void *) &Question_obj::isRedesigned,HX_("isRedesigned",5a,97,b9,20)},
	{::hx::fsBool,(void *) &Question_obj::isTap,HX_("isTap",99,84,56,c1)},
	{::hx::fsBool,(void *) &Question_obj::isColored,HX_("isColored",b8,a5,64,f3)},
	{::hx::fsBool,(void *) &Question_obj::isScrollSpeed,HX_("isScrollSpeed",70,30,6b,d4)},
	{::hx::fsInt,(void *) &Question_obj::scrollInt,HX_("scrollInt",e2,b2,01,3e)},
	{::hx::fsBool,(void *) &Question_obj::isBotPlay,HX_("isBotPlay",d1,a4,81,50)},
	{::hx::fsInt,(void *) &Question_obj::curSelected,HX_("curSelected",fb,eb,ab,32)},
	{::hx::fsBool,(void *) &Question_obj::isFPS,HX_("isFPS",1f,d6,4b,c1)},
	{::hx::fsBool,(void *) &Question_obj::isFlashing,HX_("isFlashing",3c,97,97,14)},
	{::hx::fsBool,(void *) &Question_obj::isWatermark,HX_("isWatermark",5a,66,9f,be)},
	{::hx::fsBool,(void *) &Question_obj::isMenuSong,HX_("isMenuSong",1e,63,76,cd)},
	{::hx::fsBool,(void *) &Question_obj::isAntialiasing,HX_("isAntialiasing",fe,f5,54,3f)},
	{::hx::fsBool,(void *) &Question_obj::isMidSongEvent,HX_("isMidSongEvent",67,4c,86,34)},
	{::hx::fsBool,(void *) &Question_obj::isSystemCursor,HX_("isSystemCursor",2f,d6,9f,18)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Question_obj_sMemberFields[] = {
	HX_("grpOptions",f9,45,d8,00),
	HX_("blackBox",8c,81,93,80),
	HX_("options",5e,33,fe,df),
	HX_("optionTextin",27,3b,47,42),
	HX_("onSaveData",46,c4,d3,d3),
	HX_("onSaveItem",2f,33,30,d7),
	HX_("optionText",c2,2a,95,92),
	HX_("optionEnter",63,61,dd,12),
	HX_("selectorLeft",c6,e2,77,e7),
	HX_("selectorRight",3d,98,7b,18),
	HX_("create",fc,66,0f,7c),
	HX_("update",09,86,05,87),
	HX_("changeSelection",bc,98,b5,48),
	::String(null()) };

static void Question_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Question_obj::isScroll,"isScroll");
	HX_MARK_MEMBER_NAME(Question_obj::isRedesigned,"isRedesigned");
	HX_MARK_MEMBER_NAME(Question_obj::isTap,"isTap");
	HX_MARK_MEMBER_NAME(Question_obj::isColored,"isColored");
	HX_MARK_MEMBER_NAME(Question_obj::isScrollSpeed,"isScrollSpeed");
	HX_MARK_MEMBER_NAME(Question_obj::scrollInt,"scrollInt");
	HX_MARK_MEMBER_NAME(Question_obj::isBotPlay,"isBotPlay");
	HX_MARK_MEMBER_NAME(Question_obj::curSelected,"curSelected");
	HX_MARK_MEMBER_NAME(Question_obj::isFPS,"isFPS");
	HX_MARK_MEMBER_NAME(Question_obj::isFlashing,"isFlashing");
	HX_MARK_MEMBER_NAME(Question_obj::isWatermark,"isWatermark");
	HX_MARK_MEMBER_NAME(Question_obj::isMenuSong,"isMenuSong");
	HX_MARK_MEMBER_NAME(Question_obj::isAntialiasing,"isAntialiasing");
	HX_MARK_MEMBER_NAME(Question_obj::isMidSongEvent,"isMidSongEvent");
	HX_MARK_MEMBER_NAME(Question_obj::isSystemCursor,"isSystemCursor");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Question_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Question_obj::isScroll,"isScroll");
	HX_VISIT_MEMBER_NAME(Question_obj::isRedesigned,"isRedesigned");
	HX_VISIT_MEMBER_NAME(Question_obj::isTap,"isTap");
	HX_VISIT_MEMBER_NAME(Question_obj::isColored,"isColored");
	HX_VISIT_MEMBER_NAME(Question_obj::isScrollSpeed,"isScrollSpeed");
	HX_VISIT_MEMBER_NAME(Question_obj::scrollInt,"scrollInt");
	HX_VISIT_MEMBER_NAME(Question_obj::isBotPlay,"isBotPlay");
	HX_VISIT_MEMBER_NAME(Question_obj::curSelected,"curSelected");
	HX_VISIT_MEMBER_NAME(Question_obj::isFPS,"isFPS");
	HX_VISIT_MEMBER_NAME(Question_obj::isFlashing,"isFlashing");
	HX_VISIT_MEMBER_NAME(Question_obj::isWatermark,"isWatermark");
	HX_VISIT_MEMBER_NAME(Question_obj::isMenuSong,"isMenuSong");
	HX_VISIT_MEMBER_NAME(Question_obj::isAntialiasing,"isAntialiasing");
	HX_VISIT_MEMBER_NAME(Question_obj::isMidSongEvent,"isMidSongEvent");
	HX_VISIT_MEMBER_NAME(Question_obj::isSystemCursor,"isSystemCursor");
};

#endif

::hx::Class Question_obj::__mClass;

static ::String Question_obj_sStaticFields[] = {
	HX_("isScroll",97,73,ce,9f),
	HX_("isRedesigned",5a,97,b9,20),
	HX_("isTap",99,84,56,c1),
	HX_("isColored",b8,a5,64,f3),
	HX_("isScrollSpeed",70,30,6b,d4),
	HX_("scrollInt",e2,b2,01,3e),
	HX_("isBotPlay",d1,a4,81,50),
	HX_("curSelected",fb,eb,ab,32),
	HX_("isFPS",1f,d6,4b,c1),
	HX_("isFlashing",3c,97,97,14),
	HX_("isWatermark",5a,66,9f,be),
	HX_("isMenuSong",1e,63,76,cd),
	HX_("isAntialiasing",fe,f5,54,3f),
	HX_("isMidSongEvent",67,4c,86,34),
	HX_("isSystemCursor",2f,d6,9f,18),
	::String(null())
};

void Question_obj::__register()
{
	Question_obj _hx_dummy;
	Question_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("options.Question",56,a6,3e,89);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Question_obj::__GetStatic;
	__mClass->mSetStaticField = &Question_obj::__SetStatic;
	__mClass->mMarkFunc = Question_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Question_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Question_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Question_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Question_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Question_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Question_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Question_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_41_boot)
HXDLIN(  41)		isScroll = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_42_boot)
HXDLIN(  42)		isRedesigned = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_43_boot)
HXDLIN(  43)		isTap = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_44_boot)
HXDLIN(  44)		isColored = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_45_boot)
HXDLIN(  45)		isScrollSpeed = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_46_boot)
HXDLIN(  46)		scrollInt = 1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_47_boot)
HXDLIN(  47)		isBotPlay = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_48_boot)
HXDLIN(  48)		curSelected = 0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_49_boot)
HXDLIN(  49)		isFPS = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_50_boot)
HXDLIN(  50)		isFlashing = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_51_boot)
HXDLIN(  51)		isWatermark = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_52_boot)
HXDLIN(  52)		isMenuSong = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_53_boot)
HXDLIN(  53)		isAntialiasing = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_54_boot)
HXDLIN(  54)		isMidSongEvent = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_5816709551bda8ab_55_boot)
HXDLIN(  55)		isSystemCursor = false;
            	}
}

} // end namespace options
