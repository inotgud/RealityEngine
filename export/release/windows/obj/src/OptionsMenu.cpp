// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_AccuracyDOption
#include <AccuracyDOption.h>
#endif
#ifndef INCLUDED_AccuracyOption
#include <AccuracyOption.h>
#endif
#ifndef INCLUDED_AntialiasingOption
#include <AntialiasingOption.h>
#endif
#ifndef INCLUDED_BadMsOption
#include <BadMsOption.h>
#endif
#ifndef INCLUDED_BotPlay
#include <BotPlay.h>
#endif
#ifndef INCLUDED_CamZoomOption
#include <CamZoomOption.h>
#endif
#ifndef INCLUDED_Colour
#include <Colour.h>
#endif
#ifndef INCLUDED_Controls
#include <Controls.h>
#endif
#ifndef INCLUDED_CpuStrums
#include <CpuStrums.h>
#endif
#ifndef INCLUDED_CursedOff
#include <CursedOff.h>
#endif
#ifndef INCLUDED_CursedOn
#include <CursedOn.h>
#endif
#ifndef INCLUDED_CustomizeGameplay
#include <CustomizeGameplay.h>
#endif
#ifndef INCLUDED_DFJKOption
#include <DFJKOption.h>
#endif
#ifndef INCLUDED_Debug
#include <Debug.h>
#endif
#ifndef INCLUDED_DistractionsAndEffectsOption
#include <DistractionsAndEffectsOption.h>
#endif
#ifndef INCLUDED_DownKeybind
#include <DownKeybind.h>
#endif
#ifndef INCLUDED_DownscrollOption
#include <DownscrollOption.h>
#endif
#ifndef INCLUDED_EditorRes
#include <EditorRes.h>
#endif
#ifndef INCLUDED_EngineUsernameOption
#include <EngineUsernameOption.h>
#endif
#ifndef INCLUDED_FPSCapOption
#include <FPSCapOption.h>
#endif
#ifndef INCLUDED_FPSOption
#include <FPSOption.h>
#endif
#ifndef INCLUDED_FlashingLightsOption
#include <FlashingLightsOption.h>
#endif
#ifndef INCLUDED_FullscreenBind
#include <FullscreenBind.h>
#endif
#ifndef INCLUDED_GhostTapOption
#include <GhostTapOption.h>
#endif
#ifndef INCLUDED_GoodMsOption
#include <GoodMsOption.h>
#endif
#ifndef INCLUDED_HealthBarOption
#include <HealthBarOption.h>
#endif
#ifndef INCLUDED_InstantRespawn
#include <InstantRespawn.h>
#endif
#ifndef INCLUDED_Judgement
#include <Judgement.h>
#endif
#ifndef INCLUDED_JudgementCounter
#include <JudgementCounter.h>
#endif
#ifndef INCLUDED_KeyboardSoundEffectTwo
#include <KeyboardSoundEffectTwo.h>
#endif
#ifndef INCLUDED_LaneUnderlayOption
#include <LaneUnderlayOption.h>
#endif
#ifndef INCLUDED_LeftKeybind
#include <LeftKeybind.h>
#endif
#ifndef INCLUDED_LockWeeksOption
#include <LockWeeksOption.h>
#endif
#ifndef INCLUDED_MainMenuState
#include <MainMenuState.h>
#endif
#ifndef INCLUDED_MiddleScrollOption
#include <MiddleScrollOption.h>
#endif
#ifndef INCLUDED_MissSoundsOption
#include <MissSoundsOption.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_MusicBeatSubstate
#include <MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_MuteBind
#include <MuteBind.h>
#endif
#ifndef INCLUDED_NPSDisplayOption
#include <NPSDisplayOption.h>
#endif
#ifndef INCLUDED_NoteskinOption
#include <NoteskinOption.h>
#endif
#ifndef INCLUDED_OffsetThing
#include <OffsetThing.h>
#endif
#ifndef INCLUDED_Option
#include <Option.h>
#endif
#ifndef INCLUDED_OptionCata
#include <OptionCata.h>
#endif
#ifndef INCLUDED_OptionsMenu
#include <OptionsMenu.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_PauseKeybind
#include <PauseKeybind.h>
#endif
#ifndef INCLUDED_PauseSubState
#include <PauseSubState.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_PlayStateChangeables
#include <PlayStateChangeables.h>
#endif
#ifndef INCLUDED_PlayerSettings
#include <PlayerSettings.h>
#endif
#ifndef INCLUDED_RainbowFPSOption
#include <RainbowFPSOption.h>
#endif
#ifndef INCLUDED_Ratings
#include <Ratings.h>
#endif
#ifndef INCLUDED_ReadmeOff
#include <ReadmeOff.h>
#endif
#ifndef INCLUDED_ReadmeOn
#include <ReadmeOn.h>
#endif
#ifndef INCLUDED_RedesignedMenu
#include <RedesignedMenu.h>
#endif
#ifndef INCLUDED_RedesignedMenuTwo
#include <RedesignedMenuTwo.h>
#endif
#ifndef INCLUDED_ResetBind
#include <ResetBind.h>
#endif
#ifndef INCLUDED_ResetButtonOption
#include <ResetButtonOption.h>
#endif
#ifndef INCLUDED_ResetScoreOption
#include <ResetScoreOption.h>
#endif
#ifndef INCLUDED_ResetSettings
#include <ResetSettings.h>
#endif
#ifndef INCLUDED_RightKeybind
#include <RightKeybind.h>
#endif
#ifndef INCLUDED_ScoreScreen
#include <ScoreScreen.h>
#endif
#ifndef INCLUDED_ScrollSpeedOption
#include <ScrollSpeedOption.h>
#endif
#ifndef INCLUDED_ShitMsOption
#include <ShitMsOption.h>
#endif
#ifndef INCLUDED_ShowInput
#include <ShowInput.h>
#endif
#ifndef INCLUDED_SickMSOption
#include <SickMSOption.h>
#endif
#ifndef INCLUDED_SongPositionOption
#include <SongPositionOption.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StepManiaOption
#include <StepManiaOption.h>
#endif
#ifndef INCLUDED_UpKeybind
#include <UpKeybind.h>
#endif
#ifndef INCLUDED_VolDownBind
#include <VolDownBind.h>
#endif
#ifndef INCLUDED_VolUpBind
#include <VolUpBind.h>
#endif
#ifndef INCLUDED_WatermarkOption
#include <WatermarkOption.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_actions_FlxActionSet
#include <flixel/input/actions/FlxActionSet.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadButton
#include <flixel/input/gamepad/FlxGamepadButton.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad__FlxGamepadInputID_FlxGamepadInputID_Impl_
#include <flixel/input/gamepad/_FlxGamepadInputID/FlxGamepadInputID_Impl_.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxBaseGamepadList
#include <flixel/input/gamepad/lists/FlxBaseGamepadList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_lists_FlxGamepadButtonList
#include <flixel/input/gamepad/lists/FlxGamepadButtonList.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard__FlxKey_FlxKey_Impl_
#include <flixel/input/keyboard/_FlxKey/FlxKey_Impl_.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSoundGroup
#include <flixel/system/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_CameraFrontEnd
#include <flixel/system/frontEnds/CameraFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b7c1b117f8362d86_82_new,"OptionsMenu","new",0x0f1d276f,"OptionsMenu.new","OptionsMenu.hx",82,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_118_create,"OptionsMenu","create",0x9c60a34d,"OptionsMenu.create","OptionsMenu.hx",118,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_253_switchCat,"OptionsMenu","switchCat",0x14dc1ed1,"OptionsMenu.switchCat","OptionsMenu.hx",253,0x7ae6dae1)
static const int _hx_array_data_5da343fd_9[] = {
	(int)114,(int)640,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_329_selectOption,"OptionsMenu","selectOption",0xf2e396a2,"OptionsMenu.selectOption","OptionsMenu.hx",329,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_343_update,"OptionsMenu","update",0xa756c25a,"OptionsMenu.update","OptionsMenu.hx",343,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_99_boot,"OptionsMenu","boot",0x227e5a43,"OptionsMenu.boot","OptionsMenu.hx",99,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_b7c1b117f8362d86_103_boot,"OptionsMenu","boot",0x227e5a43,"OptionsMenu.boot","OptionsMenu.hx",103,0x7ae6dae1)
static const int _hx_array_data_5da343fd_23[] = {
	(int)114,(int)640,
};

void OptionsMenu_obj::__construct(::hx::Null< bool >  __o_pauseMenu){
            		bool pauseMenu = __o_pauseMenu.Default(false);
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_82_new)
HXLINE(  95)		this->isInCat = false;
HXLINE(  93)		this->selectedOptionIndex = 0;
HXLINE(  92)		this->selectedCatIndex = 0;
HXLINE( 107)		super::__construct(null());
HXLINE( 109)		::OptionsMenu_obj::isInPause = pauseMenu;
            	}

Dynamic OptionsMenu_obj::__CreateEmpty() { return new OptionsMenu_obj; }

void *OptionsMenu_obj::_hx_vtable = 0;

Dynamic OptionsMenu_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< OptionsMenu_obj > _hx_result = new OptionsMenu_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool OptionsMenu_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x5661ffbf) {
			if (inClassId<=(int)0x109e893d) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x109e893d;
			} else {
				return inClassId==(int)0x5661ffbf;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void OptionsMenu_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_118_create)
HXLINE( 121)		 ::CursedOn _hx_tmp =  ::CursedOn_obj::__alloc( HX_CTX ,HX_("abc",62,f0,49,00));
HXLINE( 122)		 ::CursedOff _hx_tmp1 =  ::CursedOff_obj::__alloc( HX_CTX ,HX_("abc",62,f0,49,00));
HXLINE( 123)		 ::ReadmeOff _hx_tmp2 =  ::ReadmeOff_obj::__alloc( HX_CTX ,HX_("Keyboard sound effect",bb,74,5e,97));
HXLINE( 124)		 ::ReadmeOn _hx_tmp3 =  ::ReadmeOn_obj::__alloc( HX_CTX ,HX_("Keyboard sound effect",bb,74,5e,97));
HXLINE( 125)		 ::KeyboardSoundEffectTwo _hx_tmp4 =  ::KeyboardSoundEffectTwo_obj::__alloc( HX_CTX ,HX_("Keyboard sound effect",bb,74,5e,97));
HXLINE( 126)		 ::RedesignedMenu _hx_tmp5 =  ::RedesignedMenu_obj::__alloc( HX_CTX ,HX_("Redesigned menu namely Reality Engine Menu",36,17,7d,72));
HXLINE( 127)		 ::RedesignedMenuTwo _hx_tmp6 =  ::RedesignedMenuTwo_obj::__alloc( HX_CTX ,HX_("Redesigned menu namely Reality Engine Menus",7d,38,f7,ba));
HXLINE( 128)		 ::EngineUsernameOption _hx_tmp7 =  ::EngineUsernameOption_obj::__alloc( HX_CTX ,HX_("Change your funkin Reality engine name (Varies in each mode)",41,1c,1e,c7));
HXLINE( 129)		 ::ScrollSpeedOption _hx_tmp8 =  ::ScrollSpeedOption_obj::__alloc( HX_CTX ,HX_("Change your scroll speed. (1 = Chart dependent)",e3,c8,3b,f4));
HXLINE( 130)		 ::OffsetThing _hx_tmp9 =  ::OffsetThing_obj::__alloc( HX_CTX ,HX_("Change the note audio offset (how many milliseconds a note is offset in a chart)",50,8d,da,1b));
HXLINE( 131)		 ::AccuracyDOption _hx_tmp10 =  ::AccuracyDOption_obj::__alloc( HX_CTX ,HX_("Change how accuracy is calculated. (Accurate = Simple, Complex = Milisecond Based)",8a,fa,fc,fc));
HXLINE( 132)		 ::GhostTapOption _hx_tmp11 =  ::GhostTapOption_obj::__alloc( HX_CTX ,HX_("Toggle counting pressing a directional input when no arrow is there as a miss.",5c,fb,41,24));
HXLINE( 133)		 ::DownscrollOption _hx_tmp12 =  ::DownscrollOption_obj::__alloc( HX_CTX ,HX_("Toggle making the notes scroll down rather than up.",62,e3,85,ac));
HXLINE( 134)		 ::BotPlay _hx_tmp13 =  ::BotPlay_obj::__alloc( HX_CTX ,HX_("A bot plays for you!",92,28,7d,a3));
HXLINE( 135)		 ::FPSCapOption _hx_tmp14 =  ::FPSCapOption_obj::__alloc( HX_CTX ,HX_("Change your FPS Cap.",30,89,18,22));
HXLINE( 137)		 ::ResetButtonOption _hx_tmp15 =  ::ResetButtonOption_obj::__alloc( HX_CTX ,HX_("Toggle pressing R to gameover.",26,82,70,70));
HXLINE( 138)		 ::InstantRespawn _hx_tmp16 =  ::InstantRespawn_obj::__alloc( HX_CTX ,HX_("Toggle if you instantly respawn after dying.",e7,09,30,0b));
HXLINE( 139)		 ::CamZoomOption _hx_tmp17 =  ::CamZoomOption_obj::__alloc( HX_CTX ,HX_("Toggle the camera zoom in-game.",41,70,6b,49));
HXLINE( 141)		 ::DFJKOption _hx_tmp18 =  ::DFJKOption_obj::__alloc( HX_CTX );
HXLINE( 142)		 ::Judgement _hx_tmp19 =  ::Judgement_obj::__alloc( HX_CTX ,HX_("Create a custom judgement preset",f6,19,06,7d));
HXLINE( 120)		 ::OptionCata _hx_tmp20 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(50) ),( (Float)(40) ),HX_("Gameplay",06,bf,58,a5),::Array_obj< ::Dynamic>::__new(21)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,_hx_tmp2)->init(3,_hx_tmp3)->init(4,_hx_tmp4)->init(5,_hx_tmp5)->init(6,_hx_tmp6)->init(7,_hx_tmp7)->init(8,_hx_tmp8)->init(9,_hx_tmp9)->init(10,_hx_tmp10)->init(11,_hx_tmp11)->init(12,_hx_tmp12)->init(13,_hx_tmp13)->init(14,_hx_tmp14)->init(15,_hx_tmp15)->init(16,_hx_tmp16)->init(17,_hx_tmp17)->init(18,_hx_tmp18)->init(19,_hx_tmp19)->init(20, ::CustomizeGameplay_obj::__alloc( HX_CTX ,HX_("Drag and drop gameplay modules to your prefered positions!",09,7c,12,52))),null());
HXLINE( 146)		 ::NoteskinOption _hx_tmp21 =  ::NoteskinOption_obj::__alloc( HX_CTX ,HX_("Change your current noteskin",b3,76,62,eb));
HXDLIN( 146)		 ::EditorRes _hx_tmp22 =  ::EditorRes_obj::__alloc( HX_CTX ,HX_("Not showing the editor grid will greatly increase editor performance",c5,3a,66,7d));
HXLINE( 147)		 ::DistractionsAndEffectsOption _hx_tmp23 =  ::DistractionsAndEffectsOption_obj::__alloc( HX_CTX ,HX_("Toggle stage distractions that can hinder your gameplay.",0f,37,95,93));
HXLINE( 148)		 ::MiddleScrollOption _hx_tmp24 =  ::MiddleScrollOption_obj::__alloc( HX_CTX ,HX_("Put your lane in the center or on the right.",de,1b,73,d4));
HXDLIN( 148)		 ::HealthBarOption _hx_tmp25 =  ::HealthBarOption_obj::__alloc( HX_CTX ,HX_("Toggles health bar visibility",62,7b,8c,5e));
HXLINE( 149)		 ::JudgementCounter _hx_tmp26 =  ::JudgementCounter_obj::__alloc( HX_CTX ,HX_("Show your judgements that you've gotten in the song",98,0d,d9,36));
HXLINE( 150)		 ::LaneUnderlayOption _hx_tmp27 =  ::LaneUnderlayOption_obj::__alloc( HX_CTX ,HX_("How transparent your lane is, higher = more visible.",56,81,14,0a));
HXLINE( 151)		 ::StepManiaOption _hx_tmp28 =  ::StepManiaOption_obj::__alloc( HX_CTX ,HX_("Sets the colors of the arrows depending on quantization instead of direction.",42,78,c9,33));
HXLINE( 152)		 ::AccuracyOption _hx_tmp29 =  ::AccuracyOption_obj::__alloc( HX_CTX ,HX_("Display accuracy information on the info bar.",ba,58,cc,a4));
HXLINE( 153)		 ::SongPositionOption _hx_tmp30 =  ::SongPositionOption_obj::__alloc( HX_CTX ,HX_("Show the song's current position as a scrolling bar.",f0,c0,8f,57));
HXLINE( 154)		 ::Colour _hx_tmp31 =  ::Colour_obj::__alloc( HX_CTX ,HX_("The color behind icons now fit with their theme. (e.g. Pico = green)",e8,88,59,43));
HXLINE( 155)		 ::NPSDisplayOption _hx_tmp32 =  ::NPSDisplayOption_obj::__alloc( HX_CTX ,HX_("Shows your current Notes Per Second on the info bar.",bd,d5,04,b5));
HXLINE( 156)		 ::RainbowFPSOption _hx_tmp33 =  ::RainbowFPSOption_obj::__alloc( HX_CTX ,HX_("Make the FPS Counter flicker through rainbow colors.",b5,8f,ba,93));
HXLINE( 145)		 ::OptionCata _hx_tmp34 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(345) ),( (Float)(40) ),HX_("Appearance",04,ca,4d,37),::Array_obj< ::Dynamic>::__new(14)->init(0,_hx_tmp21)->init(1,_hx_tmp22)->init(2,_hx_tmp23)->init(3,_hx_tmp24)->init(4,_hx_tmp25)->init(5,_hx_tmp26)->init(6,_hx_tmp27)->init(7,_hx_tmp28)->init(8,_hx_tmp29)->init(9,_hx_tmp30)->init(10,_hx_tmp31)->init(11,_hx_tmp32)->init(12,_hx_tmp33)->init(13, ::CpuStrums_obj::__alloc( HX_CTX ,HX_("Toggle the CPU's strumline lighting up when it hits a note.",87,6c,ad,f0))),null());
HXLINE( 160)		 ::FPSOption _hx_tmp35 =  ::FPSOption_obj::__alloc( HX_CTX ,HX_("Toggle the FPS Counter",ea,68,c5,9e));
HXLINE( 161)		 ::FlashingLightsOption _hx_tmp36 =  ::FlashingLightsOption_obj::__alloc( HX_CTX ,HX_("Toggle flashing lights that can cause epileptic seizures and strain.",c8,92,75,4d));
HXLINE( 162)		 ::WatermarkOption _hx_tmp37 =  ::WatermarkOption_obj::__alloc( HX_CTX ,HX_("Enable and disable all watermarks from the engine.",bb,b5,df,79));
HXLINE( 163)		 ::AntialiasingOption _hx_tmp38 =  ::AntialiasingOption_obj::__alloc( HX_CTX ,HX_("Toggle antialiasing, improving graphics quality at a slight performance penalty.",7d,57,9f,0a));
HXLINE( 164)		 ::MissSoundsOption _hx_tmp39 =  ::MissSoundsOption_obj::__alloc( HX_CTX ,HX_("Toggle miss sounds playing when you don't hit a note.",6f,4d,eb,2e));
HXLINE( 165)		 ::ScoreScreen _hx_tmp40 =  ::ScoreScreen_obj::__alloc( HX_CTX ,HX_("Show the score screen after the end of a song",31,96,52,d3));
HXLINE( 159)		 ::OptionCata _hx_tmp41 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(640) ),( (Float)(40) ),HX_("Misc",0c,7f,35,33),::Array_obj< ::Dynamic>::__new(7)->init(0,_hx_tmp35)->init(1,_hx_tmp36)->init(2,_hx_tmp37)->init(3,_hx_tmp38)->init(4,_hx_tmp39)->init(5,_hx_tmp40)->init(6, ::ShowInput_obj::__alloc( HX_CTX ,HX_("Display every single input on the score screen.",ef,5f,8a,25))),null());
HXLINE( 171)		 ::ResetScoreOption _hx_tmp42 =  ::ResetScoreOption_obj::__alloc( HX_CTX ,HX_("Reset your score on all songs and weeks. This is irreversible!",ff,05,aa,41));
HXLINE( 172)		 ::LockWeeksOption _hx_tmp43 =  ::LockWeeksOption_obj::__alloc( HX_CTX ,HX_("Reset your story mode progress. This is irreversible!",1a,39,20,15));
HXLINE( 168)		 ::OptionCata _hx_tmp44 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(935) ),( (Float)(40) ),HX_("Saves",76,ba,b9,0a),::Array_obj< ::Dynamic>::__new(3)->init(0,_hx_tmp42)->init(1,_hx_tmp43)->init(2, ::ResetSettings_obj::__alloc( HX_CTX ,HX_("Reset ALL your settings. This is irreversible!",1d,80,bd,16))),null());
HXLINE( 176)		 ::LeftKeybind _hx_tmp45 =  ::LeftKeybind_obj::__alloc( HX_CTX ,HX_("The left note's keybind",44,52,a8,12));
HXDLIN( 176)		 ::DownKeybind _hx_tmp46 =  ::DownKeybind_obj::__alloc( HX_CTX ,HX_("The down note's keybind",49,00,37,a9));
HXDLIN( 176)		 ::UpKeybind _hx_tmp47 =  ::UpKeybind_obj::__alloc( HX_CTX ,HX_("The up note's keybind",30,74,5a,39));
HXLINE( 177)		 ::RightKeybind _hx_tmp48 =  ::RightKeybind_obj::__alloc( HX_CTX ,HX_("The right note's keybind",8d,0b,41,52));
HXDLIN( 177)		 ::PauseKeybind _hx_tmp49 =  ::PauseKeybind_obj::__alloc( HX_CTX ,HX_("The keybind used to pause the game",80,04,fc,ef));
HXLINE( 178)		 ::ResetBind _hx_tmp50 =  ::ResetBind_obj::__alloc( HX_CTX ,HX_("The keybind used to die instantly",59,b2,54,f7));
HXDLIN( 178)		 ::MuteBind _hx_tmp51 =  ::MuteBind_obj::__alloc( HX_CTX ,HX_("The keybind used to mute game audio",5a,d2,76,4c));
HXLINE( 179)		 ::VolUpBind _hx_tmp52 =  ::VolUpBind_obj::__alloc( HX_CTX ,HX_("The keybind used to turn the volume up",24,83,88,b1));
HXDLIN( 179)		 ::VolDownBind _hx_tmp53 =  ::VolDownBind_obj::__alloc( HX_CTX ,HX_("The keybind used to turn the volume down",6b,99,cd,7b));
HXLINE( 175)		 ::OptionCata _hx_tmp54 =  ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(-1) ),( (Float)(125) ),HX_("Editing Keybinds",5f,f6,bc,a7),::Array_obj< ::Dynamic>::__new(10)->init(0,_hx_tmp45)->init(1,_hx_tmp46)->init(2,_hx_tmp47)->init(3,_hx_tmp48)->init(4,_hx_tmp49)->init(5,_hx_tmp50)->init(6,_hx_tmp51)->init(7,_hx_tmp52)->init(8,_hx_tmp53)->init(9, ::FullscreenBind_obj::__alloc( HX_CTX ,HX_("The keybind used to fullscreen the game",51,64,2d,68))),true);
HXLINE( 182)		 ::SickMSOption _hx_tmp55 =  ::SickMSOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the SICK hit window",9e,76,ad,4e));
HXLINE( 183)		 ::GoodMsOption _hx_tmp56 =  ::GoodMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the GOOD hit window",7f,d0,bb,5b));
HXLINE( 184)		 ::BadMsOption _hx_tmp57 =  ::BadMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the BAD hit window",39,99,1b,7b));
HXLINE( 119)		this->options = ::Array_obj< ::Dynamic>::__new(6)->init(0,_hx_tmp20)->init(1,_hx_tmp34)->init(2,_hx_tmp41)->init(3,_hx_tmp44)->init(4,_hx_tmp54)->init(5, ::OptionCata_obj::__alloc( HX_CTX ,( (Float)(-1) ),( (Float)(125) ),HX_("Editing Judgements",66,64,14,2b),::Array_obj< ::Dynamic>::__new(4)->init(0,_hx_tmp55)->init(1,_hx_tmp56)->init(2,_hx_tmp57)->init(3, ::ShitMsOption_obj::__alloc( HX_CTX ,HX_("How many milliseconds are in the SHIT hit window",dc,ee,3d,7e))),true));
HXLINE( 189)		::OptionsMenu_obj::instance = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 191)		this->menu =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 193)		this->shownStuff =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE( 195)		this->background =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,50,40,null())->makeGraphic(1180,640,-16777216,null(),null());
HXLINE( 196)		this->background->set_alpha(((Float)0.5));
HXLINE( 197)		this->background->scrollFactor->set(null(),null());
HXLINE( 198)		this->menu->add(this->background).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 200)		this->descBack =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,50,640,null())->makeGraphic(1180,38,-16777216,null(),null());
HXLINE( 201)		this->descBack->set_alpha(((Float)0.3));
HXLINE( 202)		this->descBack->scrollFactor->set(null(),null());
HXLINE( 203)		this->menu->add(this->descBack).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 205)		if (::OptionsMenu_obj::isInPause) {
HXLINE( 207)			 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE( 208)			bg->set_alpha(( (Float)(0) ));
HXLINE( 209)			bg->scrollFactor->set(null(),null());
HXLINE( 210)			this->menu->add(bg).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 212)			this->background->set_alpha(((Float)0.5));
HXLINE( 213)			bg->set_alpha(((Float)0.6));
HXLINE( 215)			this->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,::flixel::FlxG_obj::cameras->list->__get((::flixel::FlxG_obj::cameras->list->length - 1)).StaticCast<  ::flixel::FlxCamera >()));
            		}
HXLINE( 218)		this->selectedCat = this->options->__get(0).StaticCast<  ::OptionCata >();
HXLINE( 220)		this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 222)		this->add(this->menu);
HXLINE( 224)		this->add(this->shownStuff);
HXLINE( 226)		{
HXLINE( 226)			int _g = 0;
HXDLIN( 226)			int _g1 = (this->options->length - 1);
HXDLIN( 226)			while((_g < _g1)){
HXLINE( 226)				_g = (_g + 1);
HXDLIN( 226)				int i = (_g - 1);
HXLINE( 228)				if ((i >= 4)) {
HXLINE( 229)					continue;
            				}
HXLINE( 230)				 ::OptionCata cat = this->options->__get(i).StaticCast<  ::OptionCata >();
HXLINE( 231)				this->add(cat);
HXLINE( 232)				this->add(cat->titleObject);
            			}
            		}
HXLINE( 235)		this->descText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,62,648,null(),null(),null(),null());
HXLINE( 236)		this->descText->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("muffnew.ttf",30,7e,b9,7a)),20,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 237)		this->descText->set_borderSize(( (Float)(2) ));
HXLINE( 239)		this->add(this->descBack);
HXLINE( 240)		this->add(this->descText);
HXLINE( 242)		this->isInCat = true;
HXLINE( 244)		this->switchCat(this->selectedCat,null());
HXLINE( 246)		this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 248)		this->super::create();
            	}


void OptionsMenu_obj::switchCat( ::OptionCata cat,::hx::Null< bool >  __o_checkForOutOfBounds){
            		bool checkForOutOfBounds = __o_checkForOutOfBounds.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_253_switchCat)
HXDLIN( 253)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 255)			::OptionsMenu_obj::visibleRange = ::Array_obj< int >::fromData( _hx_array_data_5da343fd_9,2);
HXLINE( 256)			if (cat->middle) {
HXLINE( 257)				::OptionsMenu_obj::visibleRange = ::Array_obj< int >::__new(2)->init(0,::Std_obj::_hx_int(cat->titleObject->y))->init(1,640);
            			}
HXLINE( 258)			if (::hx::IsNotNull( this->selectedOption )) {
HXLINE( 260)				 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 261)				object->set_text(this->selectedOption->getValue());
            			}
HXLINE( 264)			bool _hx_tmp;
HXDLIN( 264)			if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 264)				_hx_tmp = checkForOutOfBounds;
            			}
            			else {
HXLINE( 264)				_hx_tmp = false;
            			}
HXDLIN( 264)			if (_hx_tmp) {
HXLINE( 265)				this->selectedCatIndex = 0;
            			}
HXLINE( 267)			if (this->selectedCat->middle) {
HXLINE( 268)				this->remove(this->selectedCat->titleObject,null());
            			}
HXLINE( 270)			this->selectedCat->changeColor(-16777216);
HXLINE( 271)			this->selectedCat->set_alpha(((Float)0.3));
HXLINE( 273)			{
HXLINE( 273)				int _g = 0;
HXDLIN( 273)				int _g1 = this->selectedCat->options->length;
HXDLIN( 273)				while((_g < _g1)){
HXLINE( 273)					_g = (_g + 1);
HXDLIN( 273)					int i = (_g - 1);
HXLINE( 275)					 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 276)					opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            				}
            			}
HXLINE( 279)			while((this->shownStuff->members->get_length() != 0)){
HXLINE( 281)				this->shownStuff->members->remove(Dynamic( this->shownStuff->members->__get(0)).StaticCast<  ::flixel::text::FlxText >());
            			}
HXLINE( 283)			this->selectedCat = cat;
HXLINE( 284)			this->selectedCat->set_alpha(((Float)0.2));
HXLINE( 285)			this->selectedCat->changeColor(-1);
HXLINE( 287)			if (this->selectedCat->middle) {
HXLINE( 288)				this->add(this->selectedCat->titleObject);
            			}
HXLINE( 290)			{
HXLINE( 290)				 ::Dynamic filter = null();
HXDLIN( 290)				 ::flixel::group::FlxTypedGroupIterator i =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->selectedCat->optionObjects->members,filter);
HXDLIN( 290)				while(i->hasNext()){
HXLINE( 290)					 ::flixel::text::FlxText i1 = i->next().StaticCast<  ::flixel::text::FlxText >();
HXLINE( 291)					this->shownStuff->add(i1).StaticCast<  ::flixel::text::FlxText >();
            				}
            			}
HXLINE( 293)			this->selectedOption = this->selectedCat->options->__get(0).StaticCast<  ::Option >();
HXLINE( 295)			if ((this->selectedOptionIndex > (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1))) {
HXLINE( 297)				int _g = 0;
HXDLIN( 297)				int _g1 = this->selectedCat->options->length;
HXDLIN( 297)				while((_g < _g1)){
HXLINE( 297)					_g = (_g + 1);
HXDLIN( 297)					int i = (_g - 1);
HXLINE( 299)					 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 300)					opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            				}
            			}
HXLINE( 304)			this->selectedOptionIndex = 0;
HXLINE( 306)			if (!(this->isInCat)) {
HXLINE( 307)				this->selectOption(this->selectedOption);
            			}
HXLINE( 309)			{
HXLINE( 309)				int _g2 = 0;
HXDLIN( 309)				::Array< ::Dynamic> _g3 = this->selectedCat->optionObjects->members;
HXDLIN( 309)				while((_g2 < _g3->length)){
HXLINE( 309)					 ::flixel::text::FlxText i = _g3->__get(_g2).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 309)					_g2 = (_g2 + 1);
HXLINE( 311)					if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 312)						i->set_alpha(( (Float)(0) ));
            					}
            					else {
HXLINE( 313)						if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 314)							i->set_alpha(( (Float)(0) ));
            						}
            						else {
HXLINE( 317)							i->set_alpha(((Float)0.4));
            						}
            					}
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 322)				{
HXLINE( 323)					{
HXLINE( 323)						 ::Dynamic input = (HX_("oops\n",87,73,2e,33) + ::Std_obj::string(e));
HXDLIN( 323)						if (::hx::IsNotNull( input )) {
HXLINE( 323)							::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),323,HX_("OptionsMenu",fd,43,a3,5d),HX_("switchCat",82,92,35,0e)));
HXDLIN( 323)							::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 323)							::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            						}
            					}
HXLINE( 324)					this->selectedCatIndex = 0;
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(OptionsMenu_obj,switchCat,(void))

void OptionsMenu_obj::selectOption( ::Option option){
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_329_selectOption)
HXLINE( 330)		 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 332)		this->selectedOption = option;
HXLINE( 334)		if (!(this->isInCat)) {
HXLINE( 336)			object->set_text((HX_("> ",22,36,00,00) + option->getValue()));
HXLINE( 338)			 ::flixel::text::FlxText _hx_tmp = this->descText;
HXDLIN( 338)			_hx_tmp->set_text(option->getDescription());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OptionsMenu_obj,selectOption,(void))

void OptionsMenu_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_b7c1b117f8362d86_343_update)
HXLINE( 344)		this->super::update(elapsed);
HXLINE( 346)		 ::flixel::input::gamepad::FlxGamepad gamepad = ::flixel::FlxG_obj::gamepads->lastActive;
HXLINE( 348)		bool accept = false;
HXLINE( 349)		bool right = false;
HXLINE( 350)		bool left = false;
HXLINE( 351)		bool up = false;
HXLINE( 352)		bool down = false;
HXLINE( 353)		bool any = false;
HXLINE( 354)		bool escape = false;
HXLINE( 356)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 356)		if (!(_this->keyManager->checkStatusUnsafe(13,_this->status))) {
HXLINE( 356)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 356)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 356)				int id = 0;
HXDLIN( 356)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 356)				int Status = _this->status;
HXDLIN( 356)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 356)						accept = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 356)						accept = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 356)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 356)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 356)						if (::hx::IsNotNull( button )) {
HXLINE( 356)							accept = button->hasState(Status);
            						}
            						else {
HXLINE( 356)							accept = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 356)				accept = false;
            			}
            		}
            		else {
HXLINE( 356)			accept = true;
            		}
HXLINE( 357)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 357)		if (!(_this1->keyManager->checkStatusUnsafe(39,_this1->status))) {
HXLINE( 357)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 357)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 357)				int id = 14;
HXDLIN( 357)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 357)				int Status = _this->status;
HXDLIN( 357)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 357)						right = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 357)						right = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 357)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 357)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 357)						if (::hx::IsNotNull( button )) {
HXLINE( 357)							right = button->hasState(Status);
            						}
            						else {
HXLINE( 357)							right = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 357)				right = false;
            			}
            		}
            		else {
HXLINE( 357)			right = true;
            		}
HXLINE( 358)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 358)		if (!(_this2->keyManager->checkStatusUnsafe(37,_this2->status))) {
HXLINE( 358)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 358)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 358)				int id = 13;
HXDLIN( 358)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 358)				int Status = _this->status;
HXDLIN( 358)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 358)						left = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 358)						left = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 358)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 358)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 358)						if (::hx::IsNotNull( button )) {
HXLINE( 358)							left = button->hasState(Status);
            						}
            						else {
HXLINE( 358)							left = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 358)				left = false;
            			}
            		}
            		else {
HXLINE( 358)			left = true;
            		}
HXLINE( 359)		 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 359)		if (!(_this3->keyManager->checkStatusUnsafe(38,_this3->status))) {
HXLINE( 359)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 359)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 359)				int id = 11;
HXDLIN( 359)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 359)				int Status = _this->status;
HXDLIN( 359)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 359)						up = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 359)						up = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 359)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 359)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 359)						if (::hx::IsNotNull( button )) {
HXLINE( 359)							up = button->hasState(Status);
            						}
            						else {
HXLINE( 359)							up = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 359)				up = false;
            			}
            		}
            		else {
HXLINE( 359)			up = true;
            		}
HXLINE( 360)		 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 360)		if (!(_this4->keyManager->checkStatusUnsafe(40,_this4->status))) {
HXLINE( 360)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 360)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 360)				int id = 12;
HXDLIN( 360)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 360)				int Status = _this->status;
HXDLIN( 360)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 360)						down = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 360)						down = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 360)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 360)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 360)						if (::hx::IsNotNull( button )) {
HXLINE( 360)							down = button->hasState(Status);
            						}
            						else {
HXLINE( 360)							down = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 360)				down = false;
            			}
            		}
            		else {
HXLINE( 360)			down = true;
            		}
HXLINE( 362)		if (!(( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justPressed) )->get_ANY())) {
HXLINE( 362)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 362)				any = gamepad->justPressed->get_ANY();
            			}
            			else {
HXLINE( 362)				any = false;
            			}
            		}
            		else {
HXLINE( 362)			any = true;
            		}
HXLINE( 363)		 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 363)		if (!(_this5->keyManager->checkStatusUnsafe(27,_this5->status))) {
HXLINE( 363)			if (::hx::IsNotNull( gamepad )) {
HXLINE( 363)				 ::flixel::input::gamepad::lists::FlxGamepadButtonList _this = gamepad->justPressed;
HXDLIN( 363)				int id = 1;
HXDLIN( 363)				 ::flixel::input::gamepad::FlxGamepad _this1 = _this->gamepad;
HXDLIN( 363)				int Status = _this->status;
HXDLIN( 363)				switch((int)(id)){
            					case (int)-2: {
HXLINE( 363)						escape = _this1->anyButton(Status);
            					}
            					break;
            					case (int)-1: {
HXLINE( 363)						escape = !(_this1->anyButton(Status));
            					}
            					break;
            					default:{
HXLINE( 363)						int RawID = _this1->mapping->getRawID(id);
HXDLIN( 363)						 ::flixel::input::gamepad::FlxGamepadButton button = _this1->buttons->__get(RawID).StaticCast<  ::flixel::input::gamepad::FlxGamepadButton >();
HXDLIN( 363)						if (::hx::IsNotNull( button )) {
HXLINE( 363)							escape = button->hasState(Status);
            						}
            						else {
HXLINE( 363)							escape = false;
            						}
            					}
            				}
            			}
            			else {
HXLINE( 363)				escape = false;
            			}
            		}
            		else {
HXLINE( 363)			escape = true;
            		}
HXLINE( 365)		bool _hx_tmp;
HXDLIN( 365)		if (::hx::IsNotNull( this->selectedCat )) {
HXLINE( 365)			_hx_tmp = !(this->isInCat);
            		}
            		else {
HXLINE( 365)			_hx_tmp = false;
            		}
HXDLIN( 365)		if (_hx_tmp) {
HXLINE( 367)			int _g = 0;
HXDLIN( 367)			::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 367)			while((_g < _g1->length)){
HXLINE( 367)				 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 367)				_g = (_g + 1);
HXLINE( 369)				if (this->selectedCat->middle) {
HXLINE( 371)					 ::flixel::util::FlxAxes axes = ::flixel::util::FlxAxes_obj::X_dyn();
HXDLIN( 371)					if (::hx::IsNull( axes )) {
HXLINE( 371)						axes = ::flixel::util::FlxAxes_obj::XY_dyn();
            					}
HXDLIN( 371)					bool _hx_tmp;
HXDLIN( 371)					switch((int)(axes->_hx_getIndex())){
            						case (int)0: case (int)2: {
HXLINE( 371)							_hx_tmp = true;
            						}
            						break;
            						default:{
HXLINE( 371)							_hx_tmp = false;
            						}
            					}
HXDLIN( 371)					if (_hx_tmp) {
HXLINE( 371)						int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN( 371)						i->set_x(((( (Float)(_hx_tmp) ) - i->get_width()) / ( (Float)(2) )));
            					}
HXDLIN( 371)					bool _hx_tmp1;
HXDLIN( 371)					switch((int)(axes->_hx_getIndex())){
            						case (int)1: case (int)2: {
HXLINE( 371)							_hx_tmp1 = true;
            						}
            						break;
            						default:{
HXLINE( 371)							_hx_tmp1 = false;
            						}
            					}
HXDLIN( 371)					if (_hx_tmp1) {
HXLINE( 371)						int _hx_tmp = ::flixel::FlxG_obj::height;
HXDLIN( 371)						i->set_y(((( (Float)(_hx_tmp) ) - i->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE( 375)				if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 376)					i->set_alpha(( (Float)(0) ));
            				}
            				else {
HXLINE( 377)					if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 378)						i->set_alpha(( (Float)(0) ));
            					}
            					else {
HXLINE( 381)						if ((Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >()->text != i->text)) {
HXLINE( 382)							i->set_alpha(((Float)0.4));
            						}
            						else {
HXLINE( 384)							i->set_alpha(( (Float)(1) ));
            						}
            					}
            				}
            			}
            		}
HXLINE( 389)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 391)			if (this->isInCat) {
HXLINE( 393)				this->descText->set_text(HX_("Please select a category",ab,e3,01,d1));
HXLINE( 394)				if (right) {
HXLINE( 396)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 396)					_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 397)					 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 397)					_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 398)					this->selectedCatIndex++;
HXLINE( 400)					if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 401)						this->selectedCatIndex = 0;
            					}
HXLINE( 402)					if ((this->selectedCatIndex < 0)) {
HXLINE( 403)						this->selectedCatIndex = (this->options->length - 3);
            					}
HXLINE( 405)					this->switchCat(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >(),null());
            				}
            				else {
HXLINE( 407)					if (left) {
HXLINE( 409)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 409)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 410)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 410)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 411)						this->selectedCatIndex--;
HXLINE( 413)						if ((this->selectedCatIndex > (this->options->length - 3))) {
HXLINE( 414)							this->selectedCatIndex = 0;
            						}
HXLINE( 415)						if ((this->selectedCatIndex < 0)) {
HXLINE( 416)							this->selectedCatIndex = (this->options->length - 3);
            						}
HXLINE( 418)						this->switchCat(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >(),null());
            					}
            				}
HXLINE( 421)				if (accept) {
HXLINE( 423)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 423)					_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 424)					this->selectedOptionIndex = 0;
HXLINE( 425)					this->isInCat = false;
HXLINE( 426)					this->selectOption(this->selectedCat->options->__get(0).StaticCast<  ::Option >());
            				}
HXLINE( 429)				if (escape) {
HXLINE( 431)					if (!(::OptionsMenu_obj::isInPause)) {
HXLINE( 432)						 ::flixel::FlxState nextState =  ::MainMenuState_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 432)						if (::flixel::FlxG_obj::game->_state->switchTo(nextState)) {
HXLINE( 432)							::flixel::FlxG_obj::game->_requestedState = nextState;
            						}
            					}
            					else {
HXLINE( 435)						::PauseSubState_obj::goBack = true;
HXLINE( 436)						::PlayStateChangeables_obj::scrollSpeed = (( (Float)(::flixel::FlxG_obj::save->data->__Field(HX_("scrollSpeed",3a,e0,46,cb),::hx::paccDynamic)) ) * ::PlayState_obj::songMultiplier);
HXLINE( 437)						this->close();
            					}
            				}
            			}
            			else {
HXLINE( 443)				if (::hx::IsNotNull( this->selectedOption )) {
HXLINE( 444)					if (this->selectedOption->acceptType) {
HXLINE( 446)						bool _hx_tmp;
HXDLIN( 446)						if (escape) {
HXLINE( 446)							_hx_tmp = this->selectedOption->waitingType;
            						}
            						else {
HXLINE( 446)							_hx_tmp = false;
            						}
HXDLIN( 446)						if (_hx_tmp) {
HXLINE( 448)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 448)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 449)							this->selectedOption->waitingType = false;
HXLINE( 450)							 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 451)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 452)							::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),452,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
HXLINE( 453)							return;
            						}
            						else {
HXLINE( 455)							if (any) {
HXLINE( 457)								 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 458)								 ::Option _hx_tmp = this->selectedOption;
HXDLIN( 458)								::String _hx_tmp1;
HXDLIN( 458)								if (::hx::IsNull( gamepad )) {
HXLINE( 458)									int this1 = ( (int)(::flixel::FlxG_obj::keys->getIsDown()->__get(0).StaticCast<  ::flixel::input::FlxInput >()->ID) );
HXDLIN( 458)									_hx_tmp1 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get_string(this1);
            								}
            								else {
HXLINE( 458)									 ::flixel::input::gamepad::mappings::FlxGamepadMapping gamepad1 = gamepad->mapping;
HXDLIN( 458)									int this1 = gamepad1->getID(gamepad->firstJustPressedRawID());
HXDLIN( 458)									_hx_tmp1 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(this1);
            								}
HXDLIN( 458)								_hx_tmp->onType(_hx_tmp1);
HXLINE( 459)								object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 460)								::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),460,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            							}
            						}
            					}
            				}
HXLINE( 463)				bool _hx_tmp;
HXDLIN( 463)				if (!(this->selectedOption->acceptType)) {
HXLINE( 463)					_hx_tmp = !(this->selectedOption->acceptType);
            				}
            				else {
HXLINE( 463)					_hx_tmp = true;
            				}
HXDLIN( 463)				if (_hx_tmp) {
HXLINE( 465)					if (accept) {
HXLINE( 467)						int prev = this->selectedOptionIndex;
HXLINE( 468)						 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 469)						this->selectedOption->press();
HXLINE( 471)						if ((this->selectedOptionIndex == prev)) {
HXLINE( 473)							::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 475)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
            						}
            					}
HXLINE( 479)					if (down) {
HXLINE( 481)						if (this->selectedOption->acceptType) {
HXLINE( 482)							this->selectedOption->waitingType = false;
            						}
HXLINE( 483)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 483)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 484)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 484)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 485)						this->selectedOptionIndex++;
HXLINE( 489)						if ((this->selectedOptionIndex > (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1))) {
HXLINE( 491)							{
HXLINE( 491)								int _g = 0;
HXDLIN( 491)								int _g1 = this->selectedCat->options->length;
HXDLIN( 491)								while((_g < _g1)){
HXLINE( 491)									_g = (_g + 1);
HXDLIN( 491)									int i = (_g - 1);
HXLINE( 493)									 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 494)									opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            								}
            							}
HXLINE( 496)							this->selectedOptionIndex = 0;
            						}
HXLINE( 499)						bool _hx_tmp2;
HXDLIN( 499)						bool _hx_tmp3;
HXDLIN( 499)						if ((this->selectedOptionIndex != 0)) {
HXLINE( 499)							_hx_tmp3 = (this->selectedOptionIndex != (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1));
            						}
            						else {
HXLINE( 499)							_hx_tmp3 = false;
            						}
HXDLIN( 499)						if (_hx_tmp3) {
HXLINE( 499)							_hx_tmp2 = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6);
            						}
            						else {
HXLINE( 499)							_hx_tmp2 = false;
            						}
HXDLIN( 499)						if (_hx_tmp2) {
HXLINE( 503)							if ((this->selectedOptionIndex >= (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 504)								int _g = 0;
HXDLIN( 504)								::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 504)								while((_g < _g1->length)){
HXLINE( 504)									 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 504)									_g = (_g + 1);
HXLINE( 506)									{
HXLINE( 506)										 ::flixel::text::FlxText _g2 = i;
HXDLIN( 506)										_g2->set_y((_g2->y - ( (Float)(46) )));
            									}
            								}
            							}
            						}
HXLINE( 510)						this->selectOption(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->__get(this->selectedOptionIndex).StaticCast<  ::Option >());
            					}
            					else {
HXLINE( 512)						if (up) {
HXLINE( 514)							if (this->selectedOption->acceptType) {
HXLINE( 515)								this->selectedOption->waitingType = false;
            							}
HXLINE( 516)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 516)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 517)							 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 517)							_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 518)							this->selectedOptionIndex--;
HXLINE( 522)							if ((this->selectedOptionIndex < 0)) {
HXLINE( 524)								this->selectedOptionIndex = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1);
HXLINE( 526)								if ((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6)) {
HXLINE( 527)									int _g = 0;
HXDLIN( 527)									::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 527)									while((_g < _g1->length)){
HXLINE( 527)										 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 527)										_g = (_g + 1);
HXLINE( 529)										{
HXLINE( 529)											 ::flixel::text::FlxText _g2 = i;
HXDLIN( 529)											_g2->set_y((_g2->y - (( (Float)(46) ) * (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))));
            										}
            									}
            								}
            							}
HXLINE( 533)							bool _hx_tmp2;
HXDLIN( 533)							if ((this->selectedOptionIndex != 0)) {
HXLINE( 533)								_hx_tmp2 = (this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length > 6);
            							}
            							else {
HXLINE( 533)								_hx_tmp2 = false;
            							}
HXDLIN( 533)							if (_hx_tmp2) {
HXLINE( 535)								if ((this->selectedOptionIndex >= (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 536)									int _g = 0;
HXDLIN( 536)									::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 536)									while((_g < _g1->length)){
HXLINE( 536)										 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 536)										_g = (_g + 1);
HXLINE( 538)										{
HXLINE( 538)											 ::flixel::text::FlxText _g2 = i;
HXDLIN( 538)											_g2->set_y((_g2->y + 46));
            										}
            									}
            								}
            							}
HXLINE( 542)							if ((this->selectedOptionIndex < (( (Float)((this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->length - 1)) ) / ( (Float)(2) )))) {
HXLINE( 544)								int _g = 0;
HXDLIN( 544)								int _g1 = this->selectedCat->options->length;
HXDLIN( 544)								while((_g < _g1)){
HXLINE( 544)									_g = (_g + 1);
HXDLIN( 544)									int i = (_g - 1);
HXLINE( 546)									 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 547)									opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            								}
            							}
HXLINE( 551)							this->selectOption(this->options->__get(this->selectedCatIndex).StaticCast<  ::OptionCata >()->options->__get(this->selectedOptionIndex).StaticCast<  ::Option >());
            						}
            					}
HXLINE( 554)					if (right) {
HXLINE( 556)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 556)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 557)						 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 558)						this->selectedOption->right();
HXLINE( 560)						::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 562)						object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 563)						::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),563,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            					}
            					else {
HXLINE( 565)						if (left) {
HXLINE( 567)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 567)							_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 568)							 ::flixel::text::FlxText object = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 569)							this->selectedOption->left();
HXLINE( 571)							::flixel::FlxG_obj::save->flush(null(),null());
HXLINE( 573)							object->set_text((HX_("> ",22,36,00,00) + this->selectedOption->getValue()));
HXLINE( 574)							::Debug_obj::logTrace((HX_("New text: ",73,1c,99,71) + object->text),::hx::SourceInfo(HX_("source/OptionsMenu.hx",d5,ac,80,44),574,HX_("OptionsMenu",fd,43,a3,5d),HX_("update",09,86,05,87)));
            						}
            					}
HXLINE( 577)					if (escape) {
HXLINE( 579)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 579)						_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 581)						if ((this->selectedCatIndex >= 4)) {
HXLINE( 582)							this->selectedCatIndex = 0;
            						}
HXLINE( 584)						::PlayerSettings_obj::player1->controls->loadKeyBinds();
HXLINE( 586)						::Ratings_obj::timingWindows = ::Array_obj< int >::__new(4)->init(0, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("shitMs",46,83,76,22),::hx::paccDynamic)))->init(1, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("badMs",8b,b0,ae,ad),::hx::paccDynamic)))->init(2, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("goodMs",03,62,e7,61),::hx::paccDynamic)))->init(3, ::Dynamic(::flixel::FlxG_obj::save->data->__Field(HX_("sickMs",c4,fb,de,b1),::hx::paccDynamic)));
HXLINE( 593)						{
HXLINE( 593)							int _g = 0;
HXDLIN( 593)							int _g1 = this->selectedCat->options->length;
HXDLIN( 593)							while((_g < _g1)){
HXLINE( 593)								_g = (_g + 1);
HXDLIN( 593)								int i = (_g - 1);
HXLINE( 595)								 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 596)								opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            							}
            						}
HXLINE( 598)						 ::flixel::text::FlxText _hx_tmp1 = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 598)						_hx_tmp1->set_text(this->selectedOption->getValue());
HXLINE( 599)						this->isInCat = true;
HXLINE( 600)						if (::hx::IsNotNull( this->selectedCat->optionObjects )) {
HXLINE( 601)							int _g = 0;
HXDLIN( 601)							::Array< ::Dynamic> _g1 = this->selectedCat->optionObjects->members;
HXDLIN( 601)							while((_g < _g1->length)){
HXLINE( 601)								 ::flixel::text::FlxText i = _g1->__get(_g).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 601)								_g = (_g + 1);
HXLINE( 603)								if (::hx::IsNotNull( i )) {
HXLINE( 605)									if ((i->y < (::OptionsMenu_obj::visibleRange->__get(0) - 24))) {
HXLINE( 606)										i->set_alpha(( (Float)(0) ));
            									}
            									else {
HXLINE( 607)										if ((i->y > (::OptionsMenu_obj::visibleRange->__get(1) - 24))) {
HXLINE( 608)											i->set_alpha(( (Float)(0) ));
            										}
            										else {
HXLINE( 611)											i->set_alpha(((Float)0.4));
            										}
            									}
            								}
            							}
            						}
HXLINE( 615)						if (this->selectedCat->middle) {
HXLINE( 616)							this->switchCat(this->options->__get(0).StaticCast<  ::OptionCata >(),null());
            						}
            					}
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 623)				this->selectedCatIndex = 0;
HXLINE( 624)				this->selectedOptionIndex = 0;
HXLINE( 625)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 625)				_hx_tmp->play(::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
HXLINE( 626)				if (::hx::IsNotNull( this->selectedCat )) {
HXLINE( 628)					{
HXLINE( 628)						int _g = 0;
HXDLIN( 628)						int _g1 = this->selectedCat->options->length;
HXDLIN( 628)						while((_g < _g1)){
HXLINE( 628)							_g = (_g + 1);
HXDLIN( 628)							int i = (_g - 1);
HXLINE( 630)							 ::flixel::text::FlxText opt = Dynamic( this->selectedCat->optionObjects->members->__get(i)).StaticCast<  ::flixel::text::FlxText >();
HXLINE( 631)							opt->set_y(((this->selectedCat->titleObject->y + 54) + (46 * i)));
            						}
            					}
HXLINE( 633)					 ::flixel::text::FlxText _hx_tmp = Dynamic( this->selectedCat->optionObjects->members->__get(this->selectedOptionIndex)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN( 633)					_hx_tmp->set_text(this->selectedOption->getValue());
HXLINE( 634)					this->isInCat = true;
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


 ::OptionsMenu OptionsMenu_obj::instance;

bool OptionsMenu_obj::isInPause;

::Array< int > OptionsMenu_obj::visibleRange;


::hx::ObjectPtr< OptionsMenu_obj > OptionsMenu_obj::__new(::hx::Null< bool >  __o_pauseMenu) {
	::hx::ObjectPtr< OptionsMenu_obj > __this = new OptionsMenu_obj();
	__this->__construct(__o_pauseMenu);
	return __this;
}

::hx::ObjectPtr< OptionsMenu_obj > OptionsMenu_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< bool >  __o_pauseMenu) {
	OptionsMenu_obj *__this = (OptionsMenu_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(OptionsMenu_obj), true, "OptionsMenu"));
	*(void **)__this = OptionsMenu_obj::_hx_vtable;
	__this->__construct(__o_pauseMenu);
	return __this;
}

OptionsMenu_obj::OptionsMenu_obj()
{
}

void OptionsMenu_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(OptionsMenu);
	HX_MARK_MEMBER_NAME(background,"background");
	HX_MARK_MEMBER_NAME(selectedCat,"selectedCat");
	HX_MARK_MEMBER_NAME(selectedOption,"selectedOption");
	HX_MARK_MEMBER_NAME(selectedCatIndex,"selectedCatIndex");
	HX_MARK_MEMBER_NAME(selectedOptionIndex,"selectedOptionIndex");
	HX_MARK_MEMBER_NAME(isInCat,"isInCat");
	HX_MARK_MEMBER_NAME(options,"options");
	HX_MARK_MEMBER_NAME(shownStuff,"shownStuff");
	HX_MARK_MEMBER_NAME(menu,"menu");
	HX_MARK_MEMBER_NAME(descText,"descText");
	HX_MARK_MEMBER_NAME(descBack,"descBack");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void OptionsMenu_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(background,"background");
	HX_VISIT_MEMBER_NAME(selectedCat,"selectedCat");
	HX_VISIT_MEMBER_NAME(selectedOption,"selectedOption");
	HX_VISIT_MEMBER_NAME(selectedCatIndex,"selectedCatIndex");
	HX_VISIT_MEMBER_NAME(selectedOptionIndex,"selectedOptionIndex");
	HX_VISIT_MEMBER_NAME(isInCat,"isInCat");
	HX_VISIT_MEMBER_NAME(options,"options");
	HX_VISIT_MEMBER_NAME(shownStuff,"shownStuff");
	HX_VISIT_MEMBER_NAME(menu,"menu");
	HX_VISIT_MEMBER_NAME(descText,"descText");
	HX_VISIT_MEMBER_NAME(descBack,"descBack");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val OptionsMenu_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"menu") ) { return ::hx::Val( menu ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isInCat") ) { return ::hx::Val( isInCat ); }
		if (HX_FIELD_EQ(inName,"options") ) { return ::hx::Val( options ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { return ::hx::Val( descText ); }
		if (HX_FIELD_EQ(inName,"descBack") ) { return ::hx::Val( descBack ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"switchCat") ) { return ::hx::Val( switchCat_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { return ::hx::Val( background ); }
		if (HX_FIELD_EQ(inName,"shownStuff") ) { return ::hx::Val( shownStuff ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectedCat") ) { return ::hx::Val( selectedCat ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"selectOption") ) { return ::hx::Val( selectOption_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedOption") ) { return ::hx::Val( selectedOption ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"selectedCatIndex") ) { return ::hx::Val( selectedCatIndex ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"selectedOptionIndex") ) { return ::hx::Val( selectedOptionIndex ); }
	}
	return super::__Field(inName,inCallProp);
}

bool OptionsMenu_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { outValue = ( instance ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isInPause") ) { outValue = ( isInPause ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"visibleRange") ) { outValue = ( visibleRange ); return true; }
	}
	return false;
}

::hx::Val OptionsMenu_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"menu") ) { menu=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isInCat") ) { isInCat=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"options") ) { options=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"descText") ) { descText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"descBack") ) { descBack=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"background") ) { background=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shownStuff") ) { shownStuff=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectedCat") ) { selectedCat=inValue.Cast<  ::OptionCata >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedOption") ) { selectedOption=inValue.Cast<  ::Option >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"selectedCatIndex") ) { selectedCatIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"selectedOptionIndex") ) { selectedOptionIndex=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool OptionsMenu_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"instance") ) { instance=ioValue.Cast<  ::OptionsMenu >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isInPause") ) { isInPause=ioValue.Cast< bool >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"visibleRange") ) { visibleRange=ioValue.Cast< ::Array< int > >(); return true; }
	}
	return false;
}

void OptionsMenu_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("background",ee,93,1d,26));
	outFields->push(HX_("selectedCat",7b,ac,02,30));
	outFields->push(HX_("selectedOption",30,28,d9,ae));
	outFields->push(HX_("selectedCatIndex",97,40,f5,69));
	outFields->push(HX_("selectedOptionIndex",c2,34,59,a7));
	outFields->push(HX_("isInCat",e7,30,81,5a));
	outFields->push(HX_("options",5e,33,fe,df));
	outFields->push(HX_("shownStuff",63,e8,69,47));
	outFields->push(HX_("menu",9f,45,59,48));
	outFields->push(HX_("descText",9e,53,35,f3));
	outFields->push(HX_("descBack",18,61,4c,e7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo OptionsMenu_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(OptionsMenu_obj,background),HX_("background",ee,93,1d,26)},
	{::hx::fsObject /*  ::OptionCata */ ,(int)offsetof(OptionsMenu_obj,selectedCat),HX_("selectedCat",7b,ac,02,30)},
	{::hx::fsObject /*  ::Option */ ,(int)offsetof(OptionsMenu_obj,selectedOption),HX_("selectedOption",30,28,d9,ae)},
	{::hx::fsInt,(int)offsetof(OptionsMenu_obj,selectedCatIndex),HX_("selectedCatIndex",97,40,f5,69)},
	{::hx::fsInt,(int)offsetof(OptionsMenu_obj,selectedOptionIndex),HX_("selectedOptionIndex",c2,34,59,a7)},
	{::hx::fsBool,(int)offsetof(OptionsMenu_obj,isInCat),HX_("isInCat",e7,30,81,5a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(OptionsMenu_obj,options),HX_("options",5e,33,fe,df)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(OptionsMenu_obj,shownStuff),HX_("shownStuff",63,e8,69,47)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(OptionsMenu_obj,menu),HX_("menu",9f,45,59,48)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(OptionsMenu_obj,descText),HX_("descText",9e,53,35,f3)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(OptionsMenu_obj,descBack),HX_("descBack",18,61,4c,e7)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo OptionsMenu_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::OptionsMenu */ ,(void *) &OptionsMenu_obj::instance,HX_("instance",95,1f,e1,59)},
	{::hx::fsBool,(void *) &OptionsMenu_obj::isInPause,HX_("isInPause",07,2a,13,5e)},
	{::hx::fsObject /* ::Array< int > */ ,(void *) &OptionsMenu_obj::visibleRange,HX_("visibleRange",eb,bf,a4,59)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String OptionsMenu_obj_sMemberFields[] = {
	HX_("background",ee,93,1d,26),
	HX_("selectedCat",7b,ac,02,30),
	HX_("selectedOption",30,28,d9,ae),
	HX_("selectedCatIndex",97,40,f5,69),
	HX_("selectedOptionIndex",c2,34,59,a7),
	HX_("isInCat",e7,30,81,5a),
	HX_("options",5e,33,fe,df),
	HX_("shownStuff",63,e8,69,47),
	HX_("menu",9f,45,59,48),
	HX_("descText",9e,53,35,f3),
	HX_("descBack",18,61,4c,e7),
	HX_("create",fc,66,0f,7c),
	HX_("switchCat",82,92,35,0e),
	HX_("selectOption",91,c7,b2,0f),
	HX_("update",09,86,05,87),
	::String(null()) };

static void OptionsMenu_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::instance,"instance");
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::isInPause,"isInPause");
	HX_MARK_MEMBER_NAME(OptionsMenu_obj::visibleRange,"visibleRange");
};

#ifdef HXCPP_VISIT_ALLOCS
static void OptionsMenu_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::instance,"instance");
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::isInPause,"isInPause");
	HX_VISIT_MEMBER_NAME(OptionsMenu_obj::visibleRange,"visibleRange");
};

#endif

::hx::Class OptionsMenu_obj::__mClass;

static ::String OptionsMenu_obj_sStaticFields[] = {
	HX_("instance",95,1f,e1,59),
	HX_("isInPause",07,2a,13,5e),
	HX_("visibleRange",eb,bf,a4,59),
	::String(null())
};

void OptionsMenu_obj::__register()
{
	OptionsMenu_obj _hx_dummy;
	OptionsMenu_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("OptionsMenu",fd,43,a3,5d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &OptionsMenu_obj::__GetStatic;
	__mClass->mSetStaticField = &OptionsMenu_obj::__SetStatic;
	__mClass->mMarkFunc = OptionsMenu_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(OptionsMenu_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(OptionsMenu_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< OptionsMenu_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = OptionsMenu_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OptionsMenu_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OptionsMenu_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void OptionsMenu_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_99_boot)
HXDLIN(  99)		isInPause = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_b7c1b117f8362d86_103_boot)
HXDLIN( 103)		visibleRange = ::Array_obj< int >::fromData( _hx_array_data_5da343fd_23,2);
            	}
}

