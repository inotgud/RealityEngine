// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Caching
#include <Caching.h>
#endif
#ifndef INCLUDED_Debug
#include <Debug.h>
#endif
#ifndef INCLUDED_MusicBeatState
#include <MusicBeatState.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_utils_Assets
#include <openfl/utils/Assets.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_20_setCurrentLevel,"Paths","setCurrentLevel",0x8a8c27ed,"Paths.setCurrentLevel","Paths.hx",20,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_24_getPath,"Paths","getPath",0x5f104ffb,"Paths.getPath","Paths.hx",24,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_51_loadImage,"Paths","loadImage",0xed380df5,"Paths.loadImage","Paths.hx",51,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_79_loadJSON,"Paths","loadJSON",0x68f740ae,"Paths.loadJSON","Paths.hx",79,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_129_loadCharacterJSON,"Paths","loadCharacterJSON",0x41e286eb,"Paths.loadCharacterJSON","Paths.hx",129,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_154_loadCreditJSON,"Paths","loadCreditJSON",0x5afba207,"Paths.loadCreditJSON","Paths.hx",154,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_179_loadStageJson,"Paths","loadStageJson",0x2eff53a0,"Paths.loadStageJson","Paths.hx",179,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_204_loadOptionsJson,"Paths","loadOptionsJson",0x6e1e86c0,"Paths.loadOptionsJson","Paths.hx",204,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_229_loadStateJson,"Paths","loadStateJson",0x61a30473,"Paths.loadStateJson","Paths.hx",229,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_279_loadCustomGameJson,"Paths","loadCustomGameJson",0x23ca8e31,"Paths.loadCustomGameJson","Paths.hx",279,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_331_getLibraryPath,"Paths","getLibraryPath",0xe56efeaa,"Paths.getLibraryPath","Paths.hx",331,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_450_sound,"Paths","sound",0x86f65f6f,"Paths.sound","Paths.hx",450,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_497_listSongsToCache,"Paths","listSongsToCache",0xd7d84247,"Paths.listSongsToCache","Paths.hx",497,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_527_doesSoundAssetExist,"Paths","doesSoundAssetExist",0x02ff8e3d,"Paths.doesSoundAssetExist","Paths.hx",527,0x309ea470)
HX_LOCAL_STACK_FRAME(_hx_pos_d75e02b628d1544a_549_getSparrowAtlas,"Paths","getSparrowAtlas",0x5a1f05f5,"Paths.getSparrowAtlas","Paths.hx",549,0x309ea470)

void Paths_obj::__construct() { }

Dynamic Paths_obj::__CreateEmpty() { return new Paths_obj; }

void *Paths_obj::_hx_vtable = 0;

Dynamic Paths_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Paths_obj > _hx_result = new Paths_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Paths_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x44c8e46a;
}

::String Paths_obj::currentLevel;

void Paths_obj::setCurrentLevel(::String name){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_20_setCurrentLevel)
HXDLIN(  20)		::Paths_obj::currentLevel = name.toLowerCase();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Paths_obj,setCurrentLevel,(void))

::String Paths_obj::getPath(::String file,::String type,::String library){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_24_getPath)
HXLINE(  25)		if (::hx::IsNotNull( library )) {
HXLINE(  26)			return ::Paths_obj::getLibraryPath(file,library);
            		}
HXLINE(  28)		if (::hx::IsNotNull( ::Paths_obj::currentLevel )) {
HXLINE(  30)			::String library = ::Paths_obj::currentLevel;
HXDLIN(  30)			::String levelPath = (((((HX_("",00,00,00,00) + library) + HX_(":assets/",52,05,4a,2c)) + library) + HX_("/",2f,00,00,00)) + file);
HXLINE(  31)			if (::openfl::utils::Assets_obj::exists(levelPath,type)) {
HXLINE(  32)				return levelPath;
            			}
HXLINE(  34)			levelPath = ((((HX_("shared",a5,5e,2b,1d) + HX_(":assets/",52,05,4a,2c)) + HX_("shared",a5,5e,2b,1d)) + HX_("/",2f,00,00,00)) + file);
HXLINE(  35)			if (::openfl::utils::Assets_obj::exists(levelPath,type)) {
HXLINE(  36)				return levelPath;
            			}
            		}
HXLINE(  39)		return (HX_("assets/",4c,2a,dc,36) + file);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Paths_obj,getPath,return )

 ::flixel::graphics::FlxGraphic Paths_obj::loadImage(::String key,::String library){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_51_loadImage)
HXLINE(  52)		::String path = ::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + key) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),library);
HXLINE(  55)		if (::hx::IsNotNull( ::Caching_obj::bitmapData )) {
HXLINE(  57)			if (::Caching_obj::bitmapData->exists(key)) {
HXLINE(  59)				::Debug_obj::logTrace((HX_("Loading image from bitmap cache: ",24,8e,3c,e7) + key),::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),59,HX_("Paths",0e,7b,84,50),HX_("loadImage",55,6b,a0,d8)));
HXLINE(  61)				return ( ( ::flixel::graphics::FlxGraphic)(::Caching_obj::bitmapData->get(key)) );
            			}
            		}
HXLINE(  66)		if (::openfl::utils::Assets_obj::exists(path,HX_("IMAGE",3b,57,57,3b))) {
HXLINE(  68)			 ::openfl::display::BitmapData bitmap = ::openfl::utils::Assets_obj::getBitmapData(path,null());
HXLINE(  69)			return ::flixel::graphics::FlxGraphic_obj::fromBitmapData(bitmap,null(),null(),null());
            		}
            		else {
HXLINE(  73)			{
HXLINE(  73)				 ::Dynamic input = (HX_("Could not find image at path ",8e,cb,06,66) + path);
HXDLIN(  73)				if (::hx::IsNotNull( input )) {
HXLINE(  73)					::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),73,HX_("Paths",0e,7b,84,50),HX_("loadImage",55,6b,a0,d8)));
HXDLIN(  73)					::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_WARN);
HXDLIN(  73)					::Debug_obj::writeToLogFile(output,HX_("WARN",46,2a,b3,39));
            				}
            			}
HXLINE(  74)			return null();
            		}
HXLINE(  66)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadImage,return )

 ::Dynamic Paths_obj::loadJSON(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_79_loadJSON)
HXLINE(  80)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("data/",c5,0e,88,d4) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE(  83)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE(  85)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE(  88)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  91)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE(  95)				{
HXLINE(  95)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN(  95)					if (::hx::IsNotNull( input )) {
HXLINE(  95)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),95,HX_("Paths",0e,7b,84,50),HX_("loadJSON",4e,af,ef,b6)));
HXDLIN(  95)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN(  95)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE(  96)				{
HXLINE(  96)					 ::Dynamic input1 = e->get_message();
HXDLIN(  96)					if (::hx::IsNotNull( input1 )) {
HXLINE(  96)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),96,HX_("Paths",0e,7b,84,50),HX_("loadJSON",4e,af,ef,b6)));
HXDLIN(  96)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN(  96)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE(  99)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  88)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadJSON,return )

 ::Dynamic Paths_obj::loadCharacterJSON(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_129_loadCharacterJSON)
HXLINE( 130)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("custom/",5e,33,a4,60) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 133)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 135)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 138)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 141)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 145)				{
HXLINE( 145)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 145)					if (::hx::IsNotNull( input )) {
HXLINE( 145)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),145,HX_("Paths",0e,7b,84,50),HX_("loadCharacterJSON",4b,44,f7,a2)));
HXDLIN( 145)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 145)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 146)				{
HXLINE( 146)					 ::Dynamic input1 = e->get_message();
HXDLIN( 146)					if (::hx::IsNotNull( input1 )) {
HXLINE( 146)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),146,HX_("Paths",0e,7b,84,50),HX_("loadCharacterJSON",4b,44,f7,a2)));
HXDLIN( 146)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 146)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 149)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 138)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadCharacterJSON,return )

 ::Dynamic Paths_obj::loadCreditJSON(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_154_loadCreditJSON)
HXLINE( 155)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(HX_("data/credits.json",41,27,93,d3),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 158)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 160)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 163)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 166)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 170)				{
HXLINE( 170)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 170)					if (::hx::IsNotNull( input )) {
HXLINE( 170)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),170,HX_("Paths",0e,7b,84,50),HX_("loadCreditJSON",a7,c8,64,a9)));
HXDLIN( 170)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 170)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 171)				{
HXLINE( 171)					 ::Dynamic input1 = e->get_message();
HXDLIN( 171)					if (::hx::IsNotNull( input1 )) {
HXLINE( 171)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),171,HX_("Paths",0e,7b,84,50),HX_("loadCreditJSON",a7,c8,64,a9)));
HXDLIN( 171)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 171)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 174)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 163)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadCreditJSON,return )

 ::Dynamic Paths_obj::loadStageJson(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_179_loadStageJson)
HXLINE( 180)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("custom/custom_stages/",aa,10,3a,3d) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 183)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 185)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 188)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 191)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 195)				{
HXLINE( 195)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 195)					if (::hx::IsNotNull( input )) {
HXLINE( 195)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),195,HX_("Paths",0e,7b,84,50),HX_("loadStageJson",00,e1,d1,78)));
HXDLIN( 195)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 195)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 196)				{
HXLINE( 196)					 ::Dynamic input1 = e->get_message();
HXDLIN( 196)					if (::hx::IsNotNull( input1 )) {
HXLINE( 196)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),196,HX_("Paths",0e,7b,84,50),HX_("loadStageJson",00,e1,d1,78)));
HXDLIN( 196)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 196)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 199)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 188)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadStageJson,return )

 ::Dynamic Paths_obj::loadOptionsJson(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_204_loadOptionsJson)
HXLINE( 205)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("data/options/",d6,9a,7a,42) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 208)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 210)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 213)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 216)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 220)				{
HXLINE( 220)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 220)					if (::hx::IsNotNull( input )) {
HXLINE( 220)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),220,HX_("Paths",0e,7b,84,50),HX_("loadOptionsJson",20,2c,b7,bb)));
HXDLIN( 220)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 220)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 221)				{
HXLINE( 221)					 ::Dynamic input1 = e->get_message();
HXDLIN( 221)					if (::hx::IsNotNull( input1 )) {
HXLINE( 221)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),221,HX_("Paths",0e,7b,84,50),HX_("loadOptionsJson",20,2c,b7,bb)));
HXDLIN( 221)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 221)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 224)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 213)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadOptionsJson,return )

 ::Dynamic Paths_obj::loadStateJson(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_229_loadStateJson)
HXLINE( 230)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("custom/custom_states/",bd,d6,d1,45) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 233)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 235)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 238)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 241)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 245)				{
HXLINE( 245)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 245)					if (::hx::IsNotNull( input )) {
HXLINE( 245)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),245,HX_("Paths",0e,7b,84,50),HX_("loadStateJson",d3,91,75,ab)));
HXDLIN( 245)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 245)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 246)				{
HXLINE( 246)					 ::Dynamic input1 = e->get_message();
HXDLIN( 246)					if (::hx::IsNotNull( input1 )) {
HXLINE( 246)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),246,HX_("Paths",0e,7b,84,50),HX_("loadStateJson",d3,91,75,ab)));
HXDLIN( 246)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 246)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 249)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 238)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadStateJson,return )

 ::Dynamic Paths_obj::loadCustomGameJson(::String key,::String library){
            	HX_GC_STACKFRAME(&_hx_pos_d75e02b628d1544a_279_loadCustomGameJson)
HXLINE( 280)		::String rawJson = ::StringTools_obj::trim(::openfl::utils::Assets_obj::getText(::Paths_obj::getPath(((HX_("custom/custom_game/",0d,72,f9,11) + key) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),library)));
HXLINE( 283)		while(!(::StringTools_obj::endsWith(rawJson,HX_("}",7d,00,00,00)))){
HXLINE( 285)			rawJson = rawJson.substr(0,(rawJson.length - 1));
            		}
HXLINE( 288)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 291)			return  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,rawJson)->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(   1)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE( 295)				{
HXLINE( 295)					 ::Dynamic input = HX_("AN ERROR OCCURRED parsing a JSON file.",79,46,9c,b7);
HXDLIN( 295)					if (::hx::IsNotNull( input )) {
HXLINE( 295)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),295,HX_("Paths",0e,7b,84,50),HX_("loadCustomGameJson",d1,84,db,b4)));
HXDLIN( 295)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 295)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 296)				{
HXLINE( 296)					 ::Dynamic input1 = e->get_message();
HXDLIN( 296)					if (::hx::IsNotNull( input1 )) {
HXLINE( 296)						::cpp::VirtualArray output = ::Debug_obj::formatOutput(input1,::hx::SourceInfo(HX_("source/Paths.hx",64,c7,bd,1c),296,HX_("Paths",0e,7b,84,50),HX_("loadCustomGameJson",d1,84,db,b4)));
HXDLIN( 296)						::Debug_obj::writeToFlxGLog(output,::Debug_obj::LOG_STYLE_ERROR);
HXDLIN( 296)						::Debug_obj::writeToLogFile(output,HX_("ERROR",a8,03,18,f1));
            					}
            				}
HXLINE( 299)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 288)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,loadCustomGameJson,return )

::String Paths_obj::getLibraryPath(::String file,::String __o_library){
            		::String library = __o_library;
            		if (::hx::IsNull(__o_library)) library = HX_("preload",c9,47,43,35);
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_331_getLibraryPath)
HXDLIN( 331)		bool _hx_tmp;
HXDLIN( 331)		if ((library != HX_("preload",c9,47,43,35))) {
HXDLIN( 331)			_hx_tmp = (library == HX_("default",c1,d8,c3,9b));
            		}
            		else {
HXDLIN( 331)			_hx_tmp = true;
            		}
HXDLIN( 331)		if (_hx_tmp) {
HXDLIN( 331)			return (HX_("assets/",4c,2a,dc,36) + file);
            		}
            		else {
HXDLIN( 331)			return (((((HX_("",00,00,00,00) + library) + HX_(":assets/",52,05,4a,2c)) + library) + HX_("/",2f,00,00,00)) + file);
            		}
HXDLIN( 331)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,getLibraryPath,return )

::String Paths_obj::sound(::String key,::String library){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_450_sound)
HXDLIN( 450)		return ::Paths_obj::getPath((((HX_("sounds/",eb,02,a5,b6) + key) + HX_(".",2e,00,00,00)) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),library);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Paths_obj,sound,return )

::Array< ::String > Paths_obj::listSongsToCache(){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_497_listSongsToCache)
HXLINE( 499)		::Array< ::String > soundAssets = ::openfl::utils::Assets_obj::list(HX_("MUSIC",85,08,49,8e));
HXDLIN( 499)		::Array< ::String > soundAssets1 = soundAssets->concat(::openfl::utils::Assets_obj::list(HX_("SOUND",af,c4,ba,fe)));
HXLINE( 502)		::Array< ::String > songNames = ::Array_obj< ::String >::__new(0);
HXLINE( 504)		{
HXLINE( 504)			int _g = 0;
HXDLIN( 504)			while((_g < soundAssets1->length)){
HXLINE( 504)				::String sound = soundAssets1->__get(_g);
HXDLIN( 504)				_g = (_g + 1);
HXLINE( 507)				::Array< ::String > path = sound.split(HX_("/",2f,00,00,00));
HXLINE( 508)				path->reverse();
HXLINE( 510)				::String fileName = path->__get(0);
HXLINE( 511)				::String songName = path->__get(1);
HXLINE( 513)				if ((path->__get(2) != HX_("songs",fe,36,c7,80))) {
HXLINE( 514)					continue;
            				}
HXLINE( 517)				if ((songNames->indexOf(songName,null()) != -1)) {
HXLINE( 518)					continue;
            				}
HXLINE( 520)				songNames->push(songName);
            			}
            		}
HXLINE( 523)		return songNames;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Paths_obj,listSongsToCache,return )

bool Paths_obj::doesSoundAssetExist(::String path){
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_527_doesSoundAssetExist)
HXLINE( 528)		bool _hx_tmp;
HXDLIN( 528)		if (::hx::IsNotNull( path )) {
HXLINE( 528)			_hx_tmp = (path == HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 528)			_hx_tmp = true;
            		}
HXDLIN( 528)		if (_hx_tmp) {
HXLINE( 529)			return false;
            		}
HXLINE( 530)		if (!(::openfl::utils::Assets_obj::exists(path,HX_("SOUND",af,c4,ba,fe)))) {
HXLINE( 530)			return ::openfl::utils::Assets_obj::exists(path,HX_("MUSIC",85,08,49,8e));
            		}
            		else {
HXLINE( 530)			return true;
            		}
HXDLIN( 530)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Paths_obj,doesSoundAssetExist,return )

 ::flixel::graphics::frames::FlxAtlasFrames Paths_obj::getSparrowAtlas(::String key,::String library, ::Dynamic __o_isCharacter){
            		 ::Dynamic isCharacter = __o_isCharacter;
            		if (::hx::IsNull(__o_isCharacter)) isCharacter = false;
            	HX_STACKFRAME(&_hx_pos_d75e02b628d1544a_549_getSparrowAtlas)
HXLINE( 550)		if (( (bool)(isCharacter) )) {
HXLINE( 552)			 ::flixel::graphics::FlxGraphic _hx_tmp = ::Paths_obj::loadImage((HX_("characters/",45,3c,bf,be) + key),library);
HXDLIN( 552)			return ::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(_hx_tmp,::Paths_obj::getPath(((HX_("images/characters/",2e,e1,08,ac) + key) + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),library));
            		}
HXLINE( 554)		 ::flixel::graphics::FlxGraphic _hx_tmp = ::Paths_obj::loadImage(key,library);
HXDLIN( 554)		return ::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(_hx_tmp,::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + key) + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),library));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Paths_obj,getSparrowAtlas,return )


Paths_obj::Paths_obj()
{
}

bool Paths_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"sound") ) { outValue = sound_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getPath") ) { outValue = getPath_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"loadJSON") ) { outValue = loadJSON_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"loadImage") ) { outValue = loadImage_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentLevel") ) { outValue = ( currentLevel ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"loadStageJson") ) { outValue = loadStageJson_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"loadStateJson") ) { outValue = loadStateJson_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"loadCreditJSON") ) { outValue = loadCreditJSON_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getLibraryPath") ) { outValue = getLibraryPath_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"setCurrentLevel") ) { outValue = setCurrentLevel_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"loadOptionsJson") ) { outValue = loadOptionsJson_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getSparrowAtlas") ) { outValue = getSparrowAtlas_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"listSongsToCache") ) { outValue = listSongsToCache_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"loadCharacterJSON") ) { outValue = loadCharacterJSON_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"loadCustomGameJson") ) { outValue = loadCustomGameJson_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"doesSoundAssetExist") ) { outValue = doesSoundAssetExist_dyn(); return true; }
	}
	return false;
}

bool Paths_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"currentLevel") ) { currentLevel=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Paths_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Paths_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &Paths_obj::currentLevel,HX_("currentLevel",8b,fa,6e,b9)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Paths_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Paths_obj::currentLevel,"currentLevel");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Paths_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Paths_obj::currentLevel,"currentLevel");
};

#endif

::hx::Class Paths_obj::__mClass;

static ::String Paths_obj_sStaticFields[] = {
	HX_("currentLevel",8b,fa,6e,b9),
	HX_("setCurrentLevel",4d,cd,24,d8),
	HX_("getPath",5b,95,d4,1c),
	HX_("loadImage",55,6b,a0,d8),
	HX_("loadJSON",4e,af,ef,b6),
	HX_("loadCharacterJSON",4b,44,f7,a2),
	HX_("loadCreditJSON",a7,c8,64,a9),
	HX_("loadStageJson",00,e1,d1,78),
	HX_("loadOptionsJson",20,2c,b7,bb),
	HX_("loadStateJson",d3,91,75,ab),
	HX_("loadCustomGameJson",d1,84,db,b4),
	HX_("getLibraryPath",4a,25,d8,33),
	HX_("sound",cf,8c,cc,80),
	HX_("listSongsToCache",e7,50,d0,6f),
	HX_("doesSoundAssetExist",9d,63,c6,60),
	HX_("getSparrowAtlas",55,ab,b7,a7),
	::String(null())
};

void Paths_obj::__register()
{
	Paths_obj _hx_dummy;
	Paths_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Paths",0e,7b,84,50);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Paths_obj::__GetStatic;
	__mClass->mSetStaticField = &Paths_obj::__SetStatic;
	__mClass->mMarkFunc = Paths_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Paths_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Paths_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Paths_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Paths_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Paths_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

