// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_36d94048d9e4941f_19_new,"flixel.tile.FlxBaseTilemap","new",0x601e788b,"flixel.tile.FlxBaseTilemap.new","flixel/tile/FlxBaseTilemap.hx",19,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_138_getTileIndexByCoords,"flixel.tile.FlxBaseTilemap","getTileIndexByCoords",0x5f0cf078,"flixel.tile.FlxBaseTilemap.getTileIndexByCoords","flixel/tile/FlxBaseTilemap.hx",138,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_156_overlapsWithCallback,"flixel.tile.FlxBaseTilemap","overlapsWithCallback",0x90f43a8c,"flixel.tile.FlxBaseTilemap.overlapsWithCallback","flixel/tile/FlxBaseTilemap.hx",156,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_175_destroy,"flixel.tile.FlxBaseTilemap","destroy",0x44ffc6a5,"flixel.tile.FlxBaseTilemap.destroy","flixel/tile/FlxBaseTilemap.hx",175,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1251_overlaps,"flixel.tile.FlxBaseTilemap","overlaps",0x8f17af01,"flixel.tile.FlxBaseTilemap.overlaps","flixel/tile/FlxBaseTilemap.hx",1251,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1266_tilemapOverlapsCallback,"flixel.tile.FlxBaseTilemap","tilemapOverlapsCallback",0x40d17cea,"flixel.tile.FlxBaseTilemap.tilemapOverlapsCallback","flixel/tile/FlxBaseTilemap.hx",1266,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1325_overlapsPoint,"flixel.tile.FlxBaseTilemap","overlapsPoint",0x91c6718f,"flixel.tile.FlxBaseTilemap.overlapsPoint","flixel/tile/FlxBaseTilemap.hx",1325,0x0139d8e5)
HX_LOCAL_STACK_FRAME(_hx_pos_36d94048d9e4941f_1339_tileAtPointAllowsCollisions,"flixel.tile.FlxBaseTilemap","tileAtPointAllowsCollisions",0x26e8ec45,"flixel.tile.FlxBaseTilemap.tileAtPointAllowsCollisions","flixel/tile/FlxBaseTilemap.hx",1339,0x0139d8e5)
namespace flixel{
namespace tile{

void FlxBaseTilemap_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_19_new)
HXLINE(  93)		this->_tileObjects = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 167)		super::__construct(null(),null(),null(),null());
HXLINE( 169)		this->flixelType = 3;
HXLINE( 170)		this->set_immovable(true);
HXLINE( 171)		this->set_moves(false);
            	}

Dynamic FlxBaseTilemap_obj::__CreateEmpty() { return new FlxBaseTilemap_obj; }

void *FlxBaseTilemap_obj::_hx_vtable = 0;

Dynamic FlxBaseTilemap_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxBaseTilemap_obj > _hx_result = new FlxBaseTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxBaseTilemap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		if (inClassId<=(int)0x3d6253b5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x3d6253b5;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	} else {
		return inClassId==(int)0x7dab0655;
	}
}

int FlxBaseTilemap_obj::getTileIndexByCoords( ::flixel::math::FlxPoint Coord){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_138_getTileIndexByCoords)
HXDLIN( 138)		HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("getTileIndexByCoords must be implemented",7f,57,93,9c)));
HXDLIN( 138)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,getTileIndexByCoords,return )

bool FlxBaseTilemap_obj::overlapsWithCallback( ::flixel::FlxObject Object, ::Dynamic Callback,::hx::Null< bool >  __o_FlipCallbackParams, ::flixel::math::FlxPoint Position){
            		bool FlipCallbackParams = __o_FlipCallbackParams.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_156_overlapsWithCallback)
HXDLIN( 156)		HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("overlapsWithCallback must be implemented",93,a3,ff,38)));
HXDLIN( 156)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxBaseTilemap_obj,overlapsWithCallback,return )

void FlxBaseTilemap_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_175_destroy)
HXLINE( 176)		this->_data = null();
HXLINE( 177)		this->super::destroy();
            	}


bool FlxBaseTilemap_obj::overlaps( ::flixel::FlxBasic ObjectOrGroup,::hx::Null< bool >  __o_InScreenSpace, ::flixel::FlxCamera Camera){
            		bool InScreenSpace = __o_InScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1251_overlaps)
HXLINE(1252)		 ::flixel::group::FlxTypedGroup group = ::flixel::group::FlxTypedGroup_obj::resolveGroup(ObjectOrGroup);
HXLINE(1253)		if (::hx::IsNotNull( group )) {
HXLINE(1255)			return ::flixel::group::FlxTypedGroup_obj::overlaps(this->tilemapOverlapsCallback_dyn(),group,( (Float)(0) ),( (Float)(0) ),InScreenSpace,Camera);
            		}
            		else {
HXLINE(1257)			 ::flixel::FlxCamera Camera = null();
HXDLIN(1257)			bool _hx_tmp;
HXDLIN(1257)			bool _hx_tmp1;
HXDLIN(1257)			if ((ObjectOrGroup->flixelType != 1)) {
HXLINE(1257)				_hx_tmp1 = (ObjectOrGroup->flixelType == 3);
            			}
            			else {
HXLINE(1257)				_hx_tmp1 = true;
            			}
HXDLIN(1257)			if (_hx_tmp1) {
HXLINE(1257)				_hx_tmp = this->overlapsWithCallback(( ( ::flixel::FlxObject)(ObjectOrGroup) ),null(),null(),null());
            			}
            			else {
HXLINE(1257)				_hx_tmp = this->overlaps(ObjectOrGroup,false,Camera);
            			}
HXDLIN(1257)			if (_hx_tmp) {
HXLINE(1259)				return true;
            			}
            		}
HXLINE(1261)		return false;
            	}


bool FlxBaseTilemap_obj::tilemapOverlapsCallback( ::flixel::FlxBasic ObjectOrGroup,::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::hx::Null< bool >  __o_InScreenSpace, ::flixel::FlxCamera Camera){
            		Float X = __o_X.Default(0);
            		Float Y = __o_Y.Default(0);
            		bool InScreenSpace = __o_InScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1266_tilemapOverlapsCallback)
HXDLIN(1266)		bool _hx_tmp;
HXDLIN(1266)		if ((ObjectOrGroup->flixelType != 1)) {
HXDLIN(1266)			_hx_tmp = (ObjectOrGroup->flixelType == 3);
            		}
            		else {
HXDLIN(1266)			_hx_tmp = true;
            		}
HXDLIN(1266)		if (_hx_tmp) {
HXLINE(1268)			return this->overlapsWithCallback(( ( ::flixel::FlxObject)(ObjectOrGroup) ),null(),null(),null());
            		}
            		else {
HXLINE(1272)			return this->overlaps(ObjectOrGroup,InScreenSpace,Camera);
            		}
HXLINE(1266)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxBaseTilemap_obj,tilemapOverlapsCallback,return )

bool FlxBaseTilemap_obj::overlapsPoint( ::flixel::math::FlxPoint WorldPoint,::hx::Null< bool >  __o_InScreenSpace, ::flixel::FlxCamera Camera){
            		bool InScreenSpace = __o_InScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1325_overlapsPoint)
HXLINE(1326)		if (InScreenSpace) {
HXLINE(1328)			if (::hx::IsNull( Camera )) {
HXLINE(1329)				Camera = ::flixel::FlxG_obj::camera;
            			}
HXLINE(1331)			WorldPoint->subtractPoint(Camera->scroll);
HXLINE(1332)			if (WorldPoint->_weak) {
HXLINE(1332)				WorldPoint->put();
            			}
            		}
HXLINE(1335)		return this->tileAtPointAllowsCollisions(WorldPoint);
            	}


bool FlxBaseTilemap_obj::tileAtPointAllowsCollisions( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_36d94048d9e4941f_1339_tileAtPointAllowsCollisions)
HXLINE(1340)		int tileIndex = this->getTileIndexByCoords(point);
HXLINE(1341)		bool _hx_tmp;
HXDLIN(1341)		if ((tileIndex >= 0)) {
HXLINE(1341)			_hx_tmp = (tileIndex >= this->_data->length);
            		}
            		else {
HXLINE(1341)			_hx_tmp = true;
            		}
HXDLIN(1341)		if (_hx_tmp) {
HXLINE(1342)			return false;
            		}
HXLINE(1343)		return (( ( ::flixel::FlxObject)(this->_tileObjects->__get(this->_data->__get(tileIndex))) )->allowCollisions > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxBaseTilemap_obj,tileAtPointAllowsCollisions,return )


::hx::ObjectPtr< FlxBaseTilemap_obj > FlxBaseTilemap_obj::__new() {
	::hx::ObjectPtr< FlxBaseTilemap_obj > __this = new FlxBaseTilemap_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< FlxBaseTilemap_obj > FlxBaseTilemap_obj::__alloc(::hx::Ctx *_hx_ctx) {
	FlxBaseTilemap_obj *__this = (FlxBaseTilemap_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxBaseTilemap_obj), true, "flixel.tile.FlxBaseTilemap"));
	*(void **)__this = FlxBaseTilemap_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxBaseTilemap_obj::FlxBaseTilemap_obj()
{
}

void FlxBaseTilemap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxBaseTilemap);
	HX_MARK_MEMBER_NAME(_tileObjects,"_tileObjects");
	HX_MARK_MEMBER_NAME(_data,"_data");
	 ::flixel::FlxObject_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxBaseTilemap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_tileObjects,"_tileObjects");
	HX_VISIT_MEMBER_NAME(_data,"_data");
	 ::flixel::FlxObject_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxBaseTilemap_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { return ::hx::Val( _data ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"overlaps") ) { return ::hx::Val( overlaps_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tileObjects") ) { return ::hx::Val( _tileObjects ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"overlapsPoint") ) { return ::hx::Val( overlapsPoint_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"getTileIndexByCoords") ) { return ::hx::Val( getTileIndexByCoords_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlapsWithCallback") ) { return ::hx::Val( overlapsWithCallback_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"tilemapOverlapsCallback") ) { return ::hx::Val( tilemapOverlapsCallback_dyn() ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"tileAtPointAllowsCollisions") ) { return ::hx::Val( tileAtPointAllowsCollisions_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxBaseTilemap_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_data") ) { _data=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tileObjects") ) { _tileObjects=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxBaseTilemap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_tileObjects",47,55,bd,87));
	outFields->push(HX_("_data",09,72,74,f5));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxBaseTilemap_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::cpp::VirtualArray */ ,(int)offsetof(FlxBaseTilemap_obj,_tileObjects),HX_("_tileObjects",47,55,bd,87)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxBaseTilemap_obj,_data),HX_("_data",09,72,74,f5)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxBaseTilemap_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxBaseTilemap_obj_sMemberFields[] = {
	HX_("_tileObjects",47,55,bd,87),
	HX_("_data",09,72,74,f5),
	HX_("getTileIndexByCoords",03,79,8b,76),
	HX_("overlapsWithCallback",17,c3,72,a8),
	HX_("destroy",fa,2c,86,24),
	HX_("overlaps",0c,d3,2a,45),
	HX_("tilemapOverlapsCallback",3f,9d,f8,ac),
	HX_("overlapsPoint",a4,c5,bd,35),
	HX_("tileAtPointAllowsCollisions",1a,5b,2f,f6),
	::String(null()) };

::hx::Class FlxBaseTilemap_obj::__mClass;

void FlxBaseTilemap_obj::__register()
{
	FlxBaseTilemap_obj _hx_dummy;
	FlxBaseTilemap_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.tile.FlxBaseTilemap",19,d7,a6,6a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxBaseTilemap_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxBaseTilemap_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBaseTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBaseTilemap_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace tile
