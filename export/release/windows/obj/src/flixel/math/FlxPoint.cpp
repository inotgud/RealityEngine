// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_13_new,"flixel.math.FlxPoint","new",0x5991ca64,"flixel.math.FlxPoint.new","flixel/math/FlxPoint.hx",13,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_66_put,"flixel.math.FlxPoint","put",0x59935cd3,"flixel.math.FlxPoint.put","flixel/math/FlxPoint.hx",66,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_93_set,"flixel.math.FlxPoint","set",0x599595a6,"flixel.math.FlxPoint.set","flixel/math/FlxPoint.hx",93,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_120_addPoint,"flixel.math.FlxPoint","addPoint",0x1b3211eb,"flixel.math.FlxPoint.addPoint","flixel/math/FlxPoint.hx",120,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_161_subtractPoint,"flixel.math.FlxPoint","subtractPoint",0xa41aeda0,"flixel.math.FlxPoint.subtractPoint","flixel/math/FlxPoint.hx",161,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_189_scale,"flixel.math.FlxPoint","scale",0x1902518e,"flixel.math.FlxPoint.scale","flixel/math/FlxPoint.hx",189,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_216_copyTo,"flixel.math.FlxPoint","copyTo",0x56123d0c,"flixel.math.FlxPoint.copyTo","flixel/math/FlxPoint.hx",216,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_317_distanceTo,"flixel.math.FlxPoint","distanceTo",0xac8be28c,"flixel.math.FlxPoint.distanceTo","flixel/math/FlxPoint.hx",317,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_362_rotate,"flixel.math.FlxPoint","rotate",0x57ff66d7,"flixel.math.FlxPoint.rotate","flixel/math/FlxPoint.hx",362,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_383_angleBetween,"flixel.math.FlxPoint","angleBetween",0x3b318bb1,"flixel.math.FlxPoint.angleBetween","flixel/math/FlxPoint.hx",383,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_444_destroy,"flixel.math.FlxPoint","destroy",0xdae378fe,"flixel.math.FlxPoint.destroy","flixel/math/FlxPoint.hx",444,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_472_set_x,"flixel.math.FlxPoint","set_x",0x1a631e5f,"flixel.math.FlxPoint.set_x","flixel/math/FlxPoint.hx",472,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_480_set_y,"flixel.math.FlxPoint","set_y",0x1a631e60,"flixel.math.FlxPoint.set_y","flixel/math/FlxPoint.hx",480,0xb3e1cd2c)
HX_LOCAL_STACK_FRAME(_hx_pos_cceaeff5e596bc9e_17_boot,"flixel.math.FlxPoint","boot",0xfe184dae,"flixel.math.FlxPoint.boot","flixel/math/FlxPoint.hx",17,0xb3e1cd2c)
namespace flixel{
namespace math{

void FlxPoint_obj::__construct(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y){
            		Float X = __o_X.Default(0);
            		Float Y = __o_Y.Default(0);
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_13_new)
HXLINE(  53)		this->_inPool = false;
HXLINE(  52)		this->_weak = false;
HXLINE(  50)		this->y = ((Float)0);
HXLINE(  49)		this->x = ((Float)0);
HXLINE(  58)		this->set(X,Y);
            	}

Dynamic FlxPoint_obj::__CreateEmpty() { return new FlxPoint_obj; }

void *FlxPoint_obj::_hx_vtable = 0;

Dynamic FlxPoint_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxPoint_obj > _hx_result = new FlxPoint_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool FlxPoint_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x523b7d02;
}

static ::flixel::util::IFlxPooled_obj _hx_flixel_math_FlxPoint__hx_flixel_util_IFlxPooled= {
	( void (::hx::Object::*)())&::flixel::math::FlxPoint_obj::destroy,
	( void (::hx::Object::*)())&::flixel::math::FlxPoint_obj::put,
};

static ::flixel::util::IFlxDestroyable_obj _hx_flixel_math_FlxPoint__hx_flixel_util_IFlxDestroyable= {
	( void (::hx::Object::*)())&::flixel::math::FlxPoint_obj::destroy,
};

void *FlxPoint_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x9aa322a2: return &_hx_flixel_math_FlxPoint__hx_flixel_util_IFlxPooled;
		case (int)0xd4fe2fcd: return &_hx_flixel_math_FlxPoint__hx_flixel_util_IFlxDestroyable;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void FlxPoint_obj::put(){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_66_put)
HXDLIN(  66)		if (!(this->_inPool)) {
HXLINE(  68)			this->_inPool = true;
HXLINE(  69)			this->_weak = false;
HXLINE(  70)			::flixel::math::FlxPoint_obj::_pool->putUnsafe(::hx::ObjectPtr<OBJ_>(this));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxPoint_obj,put,(void))

 ::flixel::math::FlxPoint FlxPoint_obj::set(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y){
            		Float X = __o_X.Default(0);
            		Float Y = __o_Y.Default(0);
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_93_set)
HXLINE(  94)		this->set_x(X);
HXLINE(  95)		this->set_y(Y);
HXLINE(  96)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxPoint_obj,set,return )

 ::flixel::math::FlxPoint FlxPoint_obj::addPoint( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_120_addPoint)
HXLINE( 121)		{
HXLINE( 121)			{
HXLINE( 121)				 ::flixel::math::FlxPoint _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 121)				_g->set_x((_g->x + point->x));
            			}
HXDLIN( 121)			{
HXLINE( 121)				 ::flixel::math::FlxPoint _g1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 121)				_g1->set_y((_g1->y + point->y));
            			}
            		}
HXLINE( 122)		if (point->_weak) {
HXLINE( 122)			point->put();
            		}
HXLINE( 123)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,addPoint,return )

 ::flixel::math::FlxPoint FlxPoint_obj::subtractPoint( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_161_subtractPoint)
HXLINE( 162)		{
HXLINE( 162)			{
HXLINE( 162)				 ::flixel::math::FlxPoint _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 162)				_g->set_x((_g->x - point->x));
            			}
HXDLIN( 162)			{
HXLINE( 162)				 ::flixel::math::FlxPoint _g1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 162)				_g1->set_y((_g1->y - point->y));
            			}
            		}
HXLINE( 163)		if (point->_weak) {
HXLINE( 163)			point->put();
            		}
HXLINE( 164)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,subtractPoint,return )

 ::flixel::math::FlxPoint FlxPoint_obj::scale(Float k){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_189_scale)
HXLINE( 190)		{
HXLINE( 190)			 ::flixel::math::FlxPoint _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 190)			_g->set_x((_g->x * k));
            		}
HXLINE( 191)		{
HXLINE( 191)			 ::flixel::math::FlxPoint _g1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 191)			_g1->set_y((_g1->y * k));
            		}
HXLINE( 192)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,scale,return )

 ::flixel::math::FlxPoint FlxPoint_obj::copyTo( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_216_copyTo)
HXLINE( 217)		if (::hx::IsNull( point )) {
HXLINE( 219)			 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 219)			point1->_inPool = false;
HXDLIN( 219)			point = point1;
            		}
HXLINE( 221)		point->set_x(this->x);
HXLINE( 222)		point->set_y(this->y);
HXLINE( 223)		return point;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,copyTo,return )

Float FlxPoint_obj::distanceTo( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_317_distanceTo)
HXLINE( 318)		Float dx = (this->x - point->x);
HXLINE( 319)		Float dy = (this->y - point->y);
HXLINE( 320)		if (point->_weak) {
HXLINE( 320)			point->put();
            		}
HXLINE( 321)		return ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,distanceTo,return )

 ::flixel::math::FlxPoint FlxPoint_obj::rotate( ::flixel::math::FlxPoint Pivot,Float Angle){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_362_rotate)
HXLINE( 363)		Float radians = (Angle * (::Math_obj::PI / ( (Float)(180) )));
HXLINE( 364)		Float n = radians;
HXDLIN( 364)		n = (n * ((Float)0.3183098862));
HXDLIN( 364)		if ((n > 1)) {
HXLINE( 364)			n = (n - ( (Float)(((::Math_obj::ceil(n) >> 1) << 1)) ));
            		}
            		else {
HXLINE( 364)			if ((n < -1)) {
HXLINE( 364)				n = (n + ((::Math_obj::ceil(-(n)) >> 1) << 1));
            			}
            		}
HXDLIN( 364)		Float sin;
HXDLIN( 364)		if ((n > 0)) {
HXLINE( 364)			sin = (n * (((Float)3.1) + (n * (((Float)0.5) + (n * (((Float)-7.2) + (n * ((Float)3.6))))))));
            		}
            		else {
HXLINE( 364)			sin = (n * (((Float)3.1) - (n * (((Float)0.5) + (n * (((Float)7.2) + (n * ((Float)3.6))))))));
            		}
HXLINE( 365)		Float n1 = (radians + ((Float)1.570796327));
HXDLIN( 365)		n1 = (n1 * ((Float)0.3183098862));
HXDLIN( 365)		if ((n1 > 1)) {
HXLINE( 365)			n1 = (n1 - ( (Float)(((::Math_obj::ceil(n1) >> 1) << 1)) ));
            		}
            		else {
HXLINE( 365)			if ((n1 < -1)) {
HXLINE( 365)				n1 = (n1 + ((::Math_obj::ceil(-(n1)) >> 1) << 1));
            			}
            		}
HXDLIN( 365)		Float cos;
HXDLIN( 365)		if ((n1 > 0)) {
HXLINE( 365)			cos = (n1 * (((Float)3.1) + (n1 * (((Float)0.5) + (n1 * (((Float)-7.2) + (n1 * ((Float)3.6))))))));
            		}
            		else {
HXLINE( 365)			cos = (n1 * (((Float)3.1) - (n1 * (((Float)0.5) + (n1 * (((Float)7.2) + (n1 * ((Float)3.6))))))));
            		}
HXLINE( 367)		Float dx = (this->x - Pivot->x);
HXLINE( 368)		Float dy = (this->y - Pivot->y);
HXLINE( 369)		this->set_x((((cos * dx) - (sin * dy)) + Pivot->x));
HXLINE( 370)		this->set_y((((sin * dx) + (cos * dy)) + Pivot->y));
HXLINE( 372)		if (Pivot->_weak) {
HXLINE( 372)			Pivot->put();
            		}
HXLINE( 373)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxPoint_obj,rotate,return )

Float FlxPoint_obj::angleBetween( ::flixel::math::FlxPoint point){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_383_angleBetween)
HXLINE( 384)		Float x = (point->x - this->x);
HXLINE( 385)		Float y = (point->y - this->y);
HXLINE( 386)		Float angle = ( (Float)(0) );
HXLINE( 388)		bool _hx_tmp;
HXDLIN( 388)		if ((x == 0)) {
HXLINE( 388)			_hx_tmp = (y != 0);
            		}
            		else {
HXLINE( 388)			_hx_tmp = true;
            		}
HXDLIN( 388)		if (_hx_tmp) {
HXLINE( 390)			Float c1 = (::Math_obj::PI * ((Float)0.25));
HXLINE( 391)			Float c2 = (( (Float)(3) ) * c1);
HXLINE( 392)			Float ay;
HXDLIN( 392)			if ((y < 0)) {
HXLINE( 392)				ay = -(y);
            			}
            			else {
HXLINE( 392)				ay = y;
            			}
HXLINE( 394)			if ((x >= 0)) {
HXLINE( 396)				angle = (c1 - (c1 * ((x - ay) / (x + ay))));
            			}
            			else {
HXLINE( 400)				angle = (c2 - (c1 * ((x + ay) / (ay - x))));
            			}
HXLINE( 402)			Float angle1;
HXDLIN( 402)			if ((y < 0)) {
HXLINE( 402)				angle1 = -(angle);
            			}
            			else {
HXLINE( 402)				angle1 = angle;
            			}
HXDLIN( 402)			angle = (angle1 * (( (Float)(180) ) / ::Math_obj::PI));
HXLINE( 404)			if ((angle > 90)) {
HXLINE( 406)				angle = (angle - ( (Float)(270) ));
            			}
            			else {
HXLINE( 410)				angle = (angle + 90);
            			}
            		}
HXLINE( 414)		if (point->_weak) {
HXLINE( 414)			point->put();
            		}
HXLINE( 415)		return angle;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,angleBetween,return )

void FlxPoint_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_444_destroy)
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxPoint_obj,destroy,(void))

Float FlxPoint_obj::set_x(Float Value){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_472_set_x)
HXDLIN( 472)		return (this->x = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,set_x,return )

Float FlxPoint_obj::set_y(Float Value){
            	HX_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_480_set_y)
HXDLIN( 480)		return (this->y = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPoint_obj,set_y,return )

 ::flixel::util::FlxPool_flixel_math_FlxPoint FlxPoint_obj::_pool;


::hx::ObjectPtr< FlxPoint_obj > FlxPoint_obj::__new(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y) {
	::hx::ObjectPtr< FlxPoint_obj > __this = new FlxPoint_obj();
	__this->__construct(__o_X,__o_Y);
	return __this;
}

::hx::ObjectPtr< FlxPoint_obj > FlxPoint_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y) {
	FlxPoint_obj *__this = (FlxPoint_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxPoint_obj), false, "flixel.math.FlxPoint"));
	*(void **)__this = FlxPoint_obj::_hx_vtable;
	__this->__construct(__o_X,__o_Y);
	return __this;
}

FlxPoint_obj::FlxPoint_obj()
{
}

::hx::Val FlxPoint_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"put") ) { return ::hx::Val( put_dyn() ); }
		if (HX_FIELD_EQ(inName,"set") ) { return ::hx::Val( set_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_weak") ) { return ::hx::Val( _weak ); }
		if (HX_FIELD_EQ(inName,"scale") ) { return ::hx::Val( scale_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_x") ) { return ::hx::Val( set_x_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_y") ) { return ::hx::Val( set_y_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"copyTo") ) { return ::hx::Val( copyTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"rotate") ) { return ::hx::Val( rotate_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_inPool") ) { return ::hx::Val( _inPool ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addPoint") ) { return ::hx::Val( addPoint_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"distanceTo") ) { return ::hx::Val( distanceTo_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"angleBetween") ) { return ::hx::Val( angleBetween_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"subtractPoint") ) { return ::hx::Val( subtractPoint_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxPoint_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_pool") ) { outValue = ( _pool ); return true; }
	}
	return false;
}

::hx::Val FlxPoint_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_x(inValue.Cast< Float >()) );x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_y(inValue.Cast< Float >()) );y=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_weak") ) { _weak=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_inPool") ) { _inPool=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxPoint_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_pool") ) { _pool=ioValue.Cast<  ::flixel::util::FlxPool_flixel_math_FlxPoint >(); return true; }
	}
	return false;
}

void FlxPoint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("_weak",57,78,06,02));
	outFields->push(HX_("_inPool",00,71,39,f5));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxPoint_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(FlxPoint_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(FlxPoint_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsBool,(int)offsetof(FlxPoint_obj,_weak),HX_("_weak",57,78,06,02)},
	{::hx::fsBool,(int)offsetof(FlxPoint_obj,_inPool),HX_("_inPool",00,71,39,f5)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxPoint_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::util::FlxPool_flixel_math_FlxPoint */ ,(void *) &FlxPoint_obj::_pool,HX_("_pool",bb,9c,6d,fd)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxPoint_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("_weak",57,78,06,02),
	HX_("_inPool",00,71,39,f5),
	HX_("put",cf,62,55,00),
	HX_("set",a2,9b,57,00),
	HX_("addPoint",6f,da,ec,3f),
	HX_("subtractPoint",9c,c6,66,44),
	HX_("scale",8a,ce,ce,78),
	HX_("copyTo",90,1c,33,c9),
	HX_("distanceTo",10,d4,ec,8b),
	HX_("rotate",5b,46,20,cb),
	HX_("angleBetween",35,e6,d4,69),
	HX_("destroy",fa,2c,86,24),
	HX_("set_x",5b,9b,2f,7a),
	HX_("set_y",5c,9b,2f,7a),
	::String(null()) };

static void FlxPoint_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxPoint_obj::_pool,"_pool");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxPoint_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxPoint_obj::_pool,"_pool");
};

#endif

::hx::Class FlxPoint_obj::__mClass;

static ::String FlxPoint_obj_sStaticFields[] = {
	HX_("_pool",bb,9c,6d,fd),
	::String(null())
};

void FlxPoint_obj::__register()
{
	FlxPoint_obj _hx_dummy;
	FlxPoint_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.math.FlxPoint",72,08,84,d0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxPoint_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxPoint_obj::__SetStatic;
	__mClass->mMarkFunc = FlxPoint_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxPoint_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxPoint_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxPoint_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxPoint_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxPoint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxPoint_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxPoint_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_cceaeff5e596bc9e_17_boot)
HXDLIN(  17)		_pool =  ::flixel::util::FlxPool_flixel_math_FlxPoint_obj::__alloc( HX_CTX ,::hx::ClassOf< ::flixel::math::FlxPoint >());
            	}
}

} // end namespace flixel
} // end namespace math
