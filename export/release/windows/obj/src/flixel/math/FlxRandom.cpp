// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_system_FlxSound
#include <flixel/system/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_eba801adaf62ef5c_8_new,"flixel.math.FlxRandom","new",0x97b4f113,"flixel.math.FlxRandom.new","flixel/math/FlxRandom.hx",8,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_260_getObject_flixel_system_FlxSound,"flixel.math.FlxRandom","getObject_flixel_system_FlxSound",0x4e088a41,"flixel.math.FlxRandom.getObject_flixel_system_FlxSound","flixel/math/FlxRandom.hx",260,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_260_getObject_Array_String,"flixel.math.FlxRandom","getObject_Array_String",0x4ecf532e,"flixel.math.FlxRandom.getObject_Array_String","flixel/math/FlxRandom.hx",260,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_63_int,"flixel.math.FlxRandom","int",0x97b12da2,"flixel.math.FlxRandom.int","flixel/math/FlxRandom.hx",63,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_110_float,"flixel.math.FlxRandom","float",0x0d07b90f,"flixel.math.FlxRandom.float","flixel/math/FlxRandom.hx",110,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_222_weightedPick,"flixel.math.FlxRandom","weightedPick",0x1c7c1545,"flixel.math.FlxRandom.weightedPick","flixel/math/FlxRandom.hx",222,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_357_color,"flixel.math.FlxRandom","color",0x54cd64d6,"flixel.math.FlxRandom.color","flixel/math/FlxRandom.hx",357,0x4fa37e1d)
HX_LOCAL_STACK_FRAME(_hx_pos_eba801adaf62ef5c_448_boot,"flixel.math.FlxRandom","boot",0x1eb7001f,"flixel.math.FlxRandom.boot","flixel/math/FlxRandom.hx",448,0x4fa37e1d)
namespace flixel{
namespace math{

void FlxRandom_obj::__construct( ::Dynamic InitialSeed){
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_8_new)
HXLINE( 410)		this->internalSeed = ((Float)1);
HXLINE(  15)		this->initialSeed = 1;
HXLINE(  30)		if (::hx::IsNotNull( InitialSeed )) {
HXLINE(  32)			int NewSeed = ( (int)(InitialSeed) );
HXDLIN(  32)			Float lowerBound;
HXDLIN(  32)			if ((NewSeed < 1)) {
HXLINE(  32)				lowerBound = ( (Float)(1) );
            			}
            			else {
HXLINE(  32)				lowerBound = ( (Float)(NewSeed) );
            			}
HXDLIN(  32)			Float NewSeed1;
HXDLIN(  32)			if ((lowerBound > (int)2147483646)) {
HXLINE(  32)				NewSeed1 = ( (Float)((int)2147483646) );
            			}
            			else {
HXLINE(  32)				NewSeed1 = lowerBound;
            			}
HXDLIN(  32)			int NewSeed2 = ::Std_obj::_hx_int(NewSeed1);
HXDLIN(  32)			Float lowerBound1;
HXDLIN(  32)			if ((NewSeed2 < 1)) {
HXLINE(  32)				lowerBound1 = ( (Float)(1) );
            			}
            			else {
HXLINE(  32)				lowerBound1 = ( (Float)(NewSeed2) );
            			}
HXDLIN(  32)			Float _hx_tmp;
HXDLIN(  32)			if ((lowerBound1 > (int)2147483646)) {
HXLINE(  32)				_hx_tmp = ( (Float)((int)2147483646) );
            			}
            			else {
HXLINE(  32)				_hx_tmp = lowerBound1;
            			}
HXDLIN(  32)			this->initialSeed = ::Std_obj::_hx_int((this->internalSeed = ( (Float)(::Std_obj::_hx_int(_hx_tmp)) )));
            		}
            		else {
HXLINE(  36)			int Value = ::Std_obj::_hx_int((::Math_obj::random() * ( (Float)((int)2147483647) )));
HXDLIN(  36)			Float lowerBound;
HXDLIN(  36)			if ((Value < 1)) {
HXLINE(  36)				lowerBound = ( (Float)(1) );
            			}
            			else {
HXLINE(  36)				lowerBound = ( (Float)(Value) );
            			}
HXDLIN(  36)			Float NewSeed;
HXDLIN(  36)			if ((lowerBound > (int)2147483646)) {
HXLINE(  36)				NewSeed = ( (Float)((int)2147483646) );
            			}
            			else {
HXLINE(  36)				NewSeed = lowerBound;
            			}
HXDLIN(  36)			int NewSeed1 = ::Std_obj::_hx_int(NewSeed);
HXDLIN(  36)			Float lowerBound1;
HXDLIN(  36)			if ((NewSeed1 < 1)) {
HXLINE(  36)				lowerBound1 = ( (Float)(1) );
            			}
            			else {
HXLINE(  36)				lowerBound1 = ( (Float)(NewSeed1) );
            			}
HXDLIN(  36)			Float NewSeed2;
HXDLIN(  36)			if ((lowerBound1 > (int)2147483646)) {
HXLINE(  36)				NewSeed2 = ( (Float)((int)2147483646) );
            			}
            			else {
HXLINE(  36)				NewSeed2 = lowerBound1;
            			}
HXDLIN(  36)			int NewSeed3 = ::Std_obj::_hx_int(NewSeed2);
HXDLIN(  36)			Float lowerBound2;
HXDLIN(  36)			if ((NewSeed3 < 1)) {
HXLINE(  36)				lowerBound2 = ( (Float)(1) );
            			}
            			else {
HXLINE(  36)				lowerBound2 = ( (Float)(NewSeed3) );
            			}
HXDLIN(  36)			Float _hx_tmp;
HXDLIN(  36)			if ((lowerBound2 > (int)2147483646)) {
HXLINE(  36)				_hx_tmp = ( (Float)((int)2147483646) );
            			}
            			else {
HXLINE(  36)				_hx_tmp = lowerBound2;
            			}
HXDLIN(  36)			this->initialSeed = ::Std_obj::_hx_int((this->internalSeed = ( (Float)(::Std_obj::_hx_int(_hx_tmp)) )));
            		}
            	}

Dynamic FlxRandom_obj::__CreateEmpty() { return new FlxRandom_obj; }

void *FlxRandom_obj::_hx_vtable = 0;

Dynamic FlxRandom_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxRandom_obj > _hx_result = new FlxRandom_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool FlxRandom_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6232f511;
}

 ::flixel::_hx_system::FlxSound FlxRandom_obj::getObject_flixel_system_FlxSound(::Array< ::Dynamic> Objects,::Array< Float > WeightsArray,::hx::Null< int >  __o_StartIndex, ::Dynamic EndIndex){
            		int StartIndex = __o_StartIndex.Default(0);
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_260_getObject_flixel_system_FlxSound)
HXLINE( 261)		 ::flixel::_hx_system::FlxSound selected = null();
HXLINE( 263)		if ((Objects->length != 0)) {
HXLINE( 265)			if (::hx::IsNull( WeightsArray )) {
HXLINE( 267)				::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN( 267)				{
HXLINE( 267)					int _g1 = 0;
HXDLIN( 267)					int _g2 = Objects->length;
HXDLIN( 267)					while((_g1 < _g2)){
HXLINE( 267)						_g1 = (_g1 + 1);
HXDLIN( 267)						int i = (_g1 - 1);
HXDLIN( 267)						_g->push(1);
            					}
            				}
HXDLIN( 267)				WeightsArray = _g;
            			}
HXLINE( 270)			if (::hx::IsNull( EndIndex )) {
HXLINE( 272)				EndIndex = (Objects->length - 1);
            			}
HXLINE( 275)			 ::Dynamic Max = (Objects->length - 1);
HXDLIN( 275)			Float lowerBound;
HXDLIN( 275)			if ((StartIndex < 0)) {
HXLINE( 275)				lowerBound = ( (Float)(0) );
            			}
            			else {
HXLINE( 275)				lowerBound = ( (Float)(StartIndex) );
            			}
HXDLIN( 275)			Float StartIndex1;
HXDLIN( 275)			bool StartIndex2;
HXDLIN( 275)			if (::hx::IsNotNull( Max )) {
HXLINE( 275)				StartIndex2 = ::hx::IsGreater( lowerBound,Max );
            			}
            			else {
HXLINE( 275)				StartIndex2 = false;
            			}
HXDLIN( 275)			if (StartIndex2) {
HXLINE( 275)				StartIndex1 = ( (Float)(Max) );
            			}
            			else {
HXLINE( 275)				StartIndex1 = lowerBound;
            			}
HXDLIN( 275)			StartIndex = ::Std_obj::_hx_int(StartIndex1);
HXLINE( 276)			Float Value = ( (Float)(EndIndex) );
HXDLIN( 276)			 ::Dynamic Max1 = (Objects->length - 1);
HXDLIN( 276)			Float lowerBound1;
HXDLIN( 276)			if ((Value < 0)) {
HXLINE( 276)				lowerBound1 = ( (Float)(0) );
            			}
            			else {
HXLINE( 276)				lowerBound1 = Value;
            			}
HXDLIN( 276)			Float EndIndex1;
HXDLIN( 276)			bool EndIndex2;
HXDLIN( 276)			if (::hx::IsNotNull( Max1 )) {
HXLINE( 276)				EndIndex2 = ::hx::IsGreater( lowerBound1,Max1 );
            			}
            			else {
HXLINE( 276)				EndIndex2 = false;
            			}
HXDLIN( 276)			if (EndIndex2) {
HXLINE( 276)				EndIndex1 = ( (Float)(Max1) );
            			}
            			else {
HXLINE( 276)				EndIndex1 = lowerBound1;
            			}
HXDLIN( 276)			EndIndex = ::Std_obj::_hx_int(EndIndex1);
HXLINE( 279)			if (::hx::IsLess( EndIndex,StartIndex )) {
HXLINE( 281)				StartIndex = (StartIndex + EndIndex);
HXLINE( 282)				EndIndex = (StartIndex - ( (int)(EndIndex) ));
HXLINE( 283)				StartIndex = (StartIndex - ( (int)(EndIndex) ));
            			}
HXLINE( 286)			if (::hx::IsGreater( EndIndex,(WeightsArray->length - 1) )) {
HXLINE( 288)				EndIndex = (WeightsArray->length - 1);
            			}
HXLINE( 291)			::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN( 291)			{
HXLINE( 291)				int _g1 = StartIndex;
HXDLIN( 291)				int _g2 = (EndIndex + 1);
HXDLIN( 291)				while((_g1 < _g2)){
HXLINE( 291)					_g1 = (_g1 + 1);
HXDLIN( 291)					int i = (_g1 - 1);
HXDLIN( 291)					_g->push(WeightsArray->__get(i));
            				}
            			}
HXDLIN( 291)			::flixel::math::FlxRandom_obj::_arrayFloatHelper = _g;
HXLINE( 292)			selected = Objects->__get((StartIndex + this->weightedPick(::flixel::math::FlxRandom_obj::_arrayFloatHelper))).StaticCast<  ::flixel::_hx_system::FlxSound >();
            		}
HXLINE( 295)		return selected;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxRandom_obj,getObject_flixel_system_FlxSound,return )

::Array< ::String > FlxRandom_obj::getObject_Array_String(::Array< ::Dynamic> Objects,::Array< Float > WeightsArray,::hx::Null< int >  __o_StartIndex, ::Dynamic EndIndex){
            		int StartIndex = __o_StartIndex.Default(0);
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_260_getObject_Array_String)
HXLINE( 261)		::Array< ::String > selected = null();
HXLINE( 263)		if ((Objects->length != 0)) {
HXLINE( 265)			if (::hx::IsNull( WeightsArray )) {
HXLINE( 267)				::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN( 267)				{
HXLINE( 267)					int _g1 = 0;
HXDLIN( 267)					int _g2 = Objects->length;
HXDLIN( 267)					while((_g1 < _g2)){
HXLINE( 267)						_g1 = (_g1 + 1);
HXDLIN( 267)						int i = (_g1 - 1);
HXDLIN( 267)						_g->push(1);
            					}
            				}
HXDLIN( 267)				WeightsArray = _g;
            			}
HXLINE( 270)			if (::hx::IsNull( EndIndex )) {
HXLINE( 272)				EndIndex = (Objects->length - 1);
            			}
HXLINE( 275)			 ::Dynamic Max = (Objects->length - 1);
HXDLIN( 275)			Float lowerBound;
HXDLIN( 275)			if ((StartIndex < 0)) {
HXLINE( 275)				lowerBound = ( (Float)(0) );
            			}
            			else {
HXLINE( 275)				lowerBound = ( (Float)(StartIndex) );
            			}
HXDLIN( 275)			Float StartIndex1;
HXDLIN( 275)			bool StartIndex2;
HXDLIN( 275)			if (::hx::IsNotNull( Max )) {
HXLINE( 275)				StartIndex2 = ::hx::IsGreater( lowerBound,Max );
            			}
            			else {
HXLINE( 275)				StartIndex2 = false;
            			}
HXDLIN( 275)			if (StartIndex2) {
HXLINE( 275)				StartIndex1 = ( (Float)(Max) );
            			}
            			else {
HXLINE( 275)				StartIndex1 = lowerBound;
            			}
HXDLIN( 275)			StartIndex = ::Std_obj::_hx_int(StartIndex1);
HXLINE( 276)			Float Value = ( (Float)(EndIndex) );
HXDLIN( 276)			 ::Dynamic Max1 = (Objects->length - 1);
HXDLIN( 276)			Float lowerBound1;
HXDLIN( 276)			if ((Value < 0)) {
HXLINE( 276)				lowerBound1 = ( (Float)(0) );
            			}
            			else {
HXLINE( 276)				lowerBound1 = Value;
            			}
HXDLIN( 276)			Float EndIndex1;
HXDLIN( 276)			bool EndIndex2;
HXDLIN( 276)			if (::hx::IsNotNull( Max1 )) {
HXLINE( 276)				EndIndex2 = ::hx::IsGreater( lowerBound1,Max1 );
            			}
            			else {
HXLINE( 276)				EndIndex2 = false;
            			}
HXDLIN( 276)			if (EndIndex2) {
HXLINE( 276)				EndIndex1 = ( (Float)(Max1) );
            			}
            			else {
HXLINE( 276)				EndIndex1 = lowerBound1;
            			}
HXDLIN( 276)			EndIndex = ::Std_obj::_hx_int(EndIndex1);
HXLINE( 279)			if (::hx::IsLess( EndIndex,StartIndex )) {
HXLINE( 281)				StartIndex = (StartIndex + EndIndex);
HXLINE( 282)				EndIndex = (StartIndex - ( (int)(EndIndex) ));
HXLINE( 283)				StartIndex = (StartIndex - ( (int)(EndIndex) ));
            			}
HXLINE( 286)			if (::hx::IsGreater( EndIndex,(WeightsArray->length - 1) )) {
HXLINE( 288)				EndIndex = (WeightsArray->length - 1);
            			}
HXLINE( 291)			::Array< Float > _g = ::Array_obj< Float >::__new(0);
HXDLIN( 291)			{
HXLINE( 291)				int _g1 = StartIndex;
HXDLIN( 291)				int _g2 = (EndIndex + 1);
HXDLIN( 291)				while((_g1 < _g2)){
HXLINE( 291)					_g1 = (_g1 + 1);
HXDLIN( 291)					int i = (_g1 - 1);
HXDLIN( 291)					_g->push(WeightsArray->__get(i));
            				}
            			}
HXDLIN( 291)			::flixel::math::FlxRandom_obj::_arrayFloatHelper = _g;
HXLINE( 292)			selected = Objects->__get((StartIndex + this->weightedPick(::flixel::math::FlxRandom_obj::_arrayFloatHelper))).StaticCast< ::Array< ::String > >();
            		}
HXLINE( 295)		return selected;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxRandom_obj,getObject_Array_String,return )

int FlxRandom_obj::_hx_int(::hx::Null< int >  __o_Min,::hx::Null< int >  __o_Max,::Array< int > Excludes){
            		int Min = __o_Min.Default(0);
            		int Max = __o_Max.Default(2147483647);
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_63_int)
HXDLIN(  63)		bool _hx_tmp;
HXDLIN(  63)		bool _hx_tmp1;
HXDLIN(  63)		if ((Min == 0)) {
HXDLIN(  63)			_hx_tmp1 = (Max == (int)2147483647);
            		}
            		else {
HXDLIN(  63)			_hx_tmp1 = false;
            		}
HXDLIN(  63)		if (_hx_tmp1) {
HXDLIN(  63)			_hx_tmp = ::hx::IsNull( Excludes );
            		}
            		else {
HXDLIN(  63)			_hx_tmp = false;
            		}
HXDLIN(  63)		if (_hx_tmp) {
HXLINE(  65)			return ::Std_obj::_hx_int((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)));
            		}
            		else {
HXLINE(  67)			if ((Min == Max)) {
HXLINE(  69)				return Min;
            			}
            			else {
HXLINE(  74)				if ((Min > Max)) {
HXLINE(  76)					Min = (Min + Max);
HXLINE(  77)					Max = (Min - Max);
HXLINE(  78)					Min = (Min - Max);
            				}
HXLINE(  81)				if (::hx::IsNull( Excludes )) {
HXLINE(  83)					return ::Math_obj::floor((Min + (((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)) / ( (Float)((int)2147483647) )) * ( (Float)(((Max - Min) + 1)) ))));
            				}
            				else {
HXLINE(  87)					int result = 0;
HXLINE(  89)					while(true){
HXLINE(  91)						result = ::Math_obj::floor((Min + (((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)) / ( (Float)((int)2147483647) )) * ( (Float)(((Max - Min) + 1)) ))));
HXLINE(  89)						if (!((Excludes->indexOf(result,null()) >= 0))) {
HXLINE(  89)							goto _hx_goto_7;
            						}
            					}
            					_hx_goto_7:;
HXLINE(  95)					return result;
            				}
            			}
            		}
HXLINE(  63)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxRandom_obj,_hx_int,return )

Float FlxRandom_obj::_hx_float(::hx::Null< Float >  __o_Min,::hx::Null< Float >  __o_Max,::Array< Float > Excludes){
            		Float Min = __o_Min.Default(0);
            		Float Max = __o_Max.Default(1);
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_110_float)
HXLINE( 111)		Float result = ( (Float)(0) );
HXLINE( 113)		bool _hx_tmp;
HXDLIN( 113)		bool _hx_tmp1;
HXDLIN( 113)		if ((Min == 0)) {
HXLINE( 113)			_hx_tmp1 = (Max == 1);
            		}
            		else {
HXLINE( 113)			_hx_tmp1 = false;
            		}
HXDLIN( 113)		if (_hx_tmp1) {
HXLINE( 113)			_hx_tmp = ::hx::IsNull( Excludes );
            		}
            		else {
HXLINE( 113)			_hx_tmp = false;
            		}
HXDLIN( 113)		if (_hx_tmp) {
HXLINE( 115)			return ((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)) / ( (Float)((int)2147483647) ));
            		}
            		else {
HXLINE( 117)			if ((Min == Max)) {
HXLINE( 119)				result = Min;
            			}
            			else {
HXLINE( 124)				if ((Min > Max)) {
HXLINE( 126)					Min = (Min + Max);
HXLINE( 127)					Max = (Min - Max);
HXLINE( 128)					Min = (Min - Max);
            				}
HXLINE( 131)				if (::hx::IsNull( Excludes )) {
HXLINE( 133)					result = (Min + (((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)) / ( (Float)((int)2147483647) )) * (Max - Min)));
            				}
            				else {
HXLINE( 137)					while(true){
HXLINE( 139)						result = (Min + (((this->internalSeed = ::hx::Mod((this->internalSeed * ((Float)48271.0)),(int)2147483647)) / ( (Float)((int)2147483647) )) * (Max - Min)));
HXLINE( 137)						if (!((Excludes->indexOf(result,null()) >= 0))) {
HXLINE( 137)							goto _hx_goto_9;
            						}
            					}
            					_hx_goto_9:;
            				}
            			}
            		}
HXLINE( 145)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxRandom_obj,_hx_float,return )

int FlxRandom_obj::weightedPick(::Array< Float > WeightsArray){
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_222_weightedPick)
HXLINE( 223)		Float totalWeight = ( (Float)(0) );
HXLINE( 224)		int pick = 0;
HXLINE( 226)		{
HXLINE( 226)			int _g = 0;
HXDLIN( 226)			while((_g < WeightsArray->length)){
HXLINE( 226)				Float i = WeightsArray->__get(_g);
HXDLIN( 226)				_g = (_g + 1);
HXLINE( 228)				totalWeight = (totalWeight + i);
            			}
            		}
HXLINE( 231)		totalWeight = this->_hx_float(0,totalWeight,null());
HXLINE( 233)		{
HXLINE( 233)			int _g1 = 0;
HXDLIN( 233)			int _g2 = WeightsArray->length;
HXDLIN( 233)			while((_g1 < _g2)){
HXLINE( 233)				_g1 = (_g1 + 1);
HXDLIN( 233)				int i = (_g1 - 1);
HXLINE( 235)				if ((totalWeight < WeightsArray->__get(i))) {
HXLINE( 237)					pick = i;
HXLINE( 238)					goto _hx_goto_12;
            				}
HXLINE( 241)				totalWeight = (totalWeight - WeightsArray->__get(i));
            			}
            			_hx_goto_12:;
            		}
HXLINE( 244)		return pick;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxRandom_obj,weightedPick,return )

int FlxRandom_obj::color( ::Dynamic Min, ::Dynamic Max, ::Dynamic Alpha,::hx::Null< bool >  __o_GreyScale){
            		bool GreyScale = __o_GreyScale.Default(false);
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_357_color)
HXLINE( 358)		int red;
HXLINE( 359)		int green;
HXLINE( 360)		int blue;
HXLINE( 361)		int alpha;
HXLINE( 363)		bool _hx_tmp;
HXDLIN( 363)		if (::hx::IsNull( Min )) {
HXLINE( 363)			_hx_tmp = ::hx::IsNull( Max );
            		}
            		else {
HXLINE( 363)			_hx_tmp = false;
            		}
HXDLIN( 363)		if (_hx_tmp) {
HXLINE( 365)			red = this->_hx_int(0,255,null());
HXLINE( 366)			green = this->_hx_int(0,255,null());
HXLINE( 367)			blue = this->_hx_int(0,255,null());
HXLINE( 368)			if (::hx::IsNull( Alpha )) {
HXLINE( 368)				alpha = this->_hx_int(0,255,null());
            			}
            			else {
HXLINE( 368)				alpha = ( (int)(Alpha) );
            			}
            		}
            		else {
HXLINE( 370)			if (::hx::IsNull( Max )) {
HXLINE( 372)				red = this->_hx_int(((( (int)(Min) ) >> 16) & 255),255,null());
HXLINE( 373)				if (GreyScale) {
HXLINE( 373)					green = red;
            				}
            				else {
HXLINE( 373)					green = this->_hx_int(((( (int)(Min) ) >> 8) & 255),255,null());
            				}
HXLINE( 374)				if (GreyScale) {
HXLINE( 374)					blue = red;
            				}
            				else {
HXLINE( 374)					blue = this->_hx_int((( (int)(Min) ) & 255),255,null());
            				}
HXLINE( 375)				if (::hx::IsNull( Alpha )) {
HXLINE( 375)					alpha = this->_hx_int(((( (int)(Min) ) >> 24) & 255),255,null());
            				}
            				else {
HXLINE( 375)					alpha = ( (int)(Alpha) );
            				}
            			}
            			else {
HXLINE( 377)				if (::hx::IsNull( Min )) {
HXLINE( 379)					red = this->_hx_int(0,((( (int)(Max) ) >> 16) & 255),null());
HXLINE( 380)					if (GreyScale) {
HXLINE( 380)						green = red;
            					}
            					else {
HXLINE( 380)						green = this->_hx_int(0,((( (int)(Max) ) >> 8) & 255),null());
            					}
HXLINE( 381)					if (GreyScale) {
HXLINE( 381)						blue = red;
            					}
            					else {
HXLINE( 381)						blue = this->_hx_int(0,(( (int)(Max) ) & 255),null());
            					}
HXLINE( 382)					if (::hx::IsNull( Alpha )) {
HXLINE( 382)						alpha = this->_hx_int(0,((( (int)(Max) ) >> 24) & 255),null());
            					}
            					else {
HXLINE( 382)						alpha = ( (int)(Alpha) );
            					}
            				}
            				else {
HXLINE( 386)					red = this->_hx_int(((( (int)(Min) ) >> 16) & 255),((( (int)(Max) ) >> 16) & 255),null());
HXLINE( 387)					if (GreyScale) {
HXLINE( 387)						green = red;
            					}
            					else {
HXLINE( 387)						green = this->_hx_int(((( (int)(Min) ) >> 8) & 255),((( (int)(Max) ) >> 8) & 255),null());
            					}
HXLINE( 388)					if (GreyScale) {
HXLINE( 388)						blue = red;
            					}
            					else {
HXLINE( 388)						blue = this->_hx_int((( (int)(Min) ) & 255),(( (int)(Max) ) & 255),null());
            					}
HXLINE( 389)					if (::hx::IsNull( Alpha )) {
HXLINE( 389)						alpha = this->_hx_int(((( (int)(Min) ) >> 24) & 255),((( (int)(Max) ) >> 24) & 255),null());
            					}
            					else {
HXLINE( 389)						alpha = ( (int)(Alpha) );
            					}
            				}
            			}
            		}
HXLINE( 392)		int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 392)		{
HXLINE( 392)			color = (color & -16711681);
HXDLIN( 392)			int color1;
HXDLIN( 392)			if ((red > 255)) {
HXLINE( 392)				color1 = 255;
            			}
            			else {
HXLINE( 392)				if ((red < 0)) {
HXLINE( 392)					color1 = 0;
            				}
            				else {
HXLINE( 392)					color1 = red;
            				}
            			}
HXDLIN( 392)			color = (color | (color1 << 16));
            		}
HXDLIN( 392)		{
HXLINE( 392)			color = (color & -65281);
HXDLIN( 392)			int color2;
HXDLIN( 392)			if ((green > 255)) {
HXLINE( 392)				color2 = 255;
            			}
            			else {
HXLINE( 392)				if ((green < 0)) {
HXLINE( 392)					color2 = 0;
            				}
            				else {
HXLINE( 392)					color2 = green;
            				}
            			}
HXDLIN( 392)			color = (color | (color2 << 8));
            		}
HXDLIN( 392)		{
HXLINE( 392)			color = (color & -256);
HXDLIN( 392)			int color3;
HXDLIN( 392)			if ((blue > 255)) {
HXLINE( 392)				color3 = 255;
            			}
            			else {
HXLINE( 392)				if ((blue < 0)) {
HXLINE( 392)					color3 = 0;
            				}
            				else {
HXLINE( 392)					color3 = blue;
            				}
            			}
HXDLIN( 392)			color = (color | color3);
            		}
HXDLIN( 392)		{
HXLINE( 392)			color = (color & 16777215);
HXDLIN( 392)			int color4;
HXDLIN( 392)			if ((alpha > 255)) {
HXLINE( 392)				color4 = 255;
            			}
            			else {
HXLINE( 392)				if ((alpha < 0)) {
HXLINE( 392)					color4 = 0;
            				}
            				else {
HXLINE( 392)					color4 = alpha;
            				}
            			}
HXDLIN( 392)			color = (color | (color4 << 24));
            		}
HXDLIN( 392)		return color;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxRandom_obj,color,return )

::Array< Float > FlxRandom_obj::_arrayFloatHelper;


::hx::ObjectPtr< FlxRandom_obj > FlxRandom_obj::__new( ::Dynamic InitialSeed) {
	::hx::ObjectPtr< FlxRandom_obj > __this = new FlxRandom_obj();
	__this->__construct(InitialSeed);
	return __this;
}

::hx::ObjectPtr< FlxRandom_obj > FlxRandom_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic InitialSeed) {
	FlxRandom_obj *__this = (FlxRandom_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxRandom_obj), false, "flixel.math.FlxRandom"));
	*(void **)__this = FlxRandom_obj::_hx_vtable;
	__this->__construct(InitialSeed);
	return __this;
}

FlxRandom_obj::FlxRandom_obj()
{
}

::hx::Val FlxRandom_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"int") ) { return ::hx::Val( _hx_int_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"float") ) { return ::hx::Val( _hx_float_dyn() ); }
		if (HX_FIELD_EQ(inName,"color") ) { return ::hx::Val( color_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"initialSeed") ) { return ::hx::Val( initialSeed ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"weightedPick") ) { return ::hx::Val( weightedPick_dyn() ); }
		if (HX_FIELD_EQ(inName,"internalSeed") ) { return ::hx::Val( internalSeed ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"getObject_Array_String") ) { return ::hx::Val( getObject_Array_String_dyn() ); }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"getObject_flixel_system_FlxSound") ) { return ::hx::Val( getObject_flixel_system_FlxSound_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxRandom_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"_arrayFloatHelper") ) { outValue = ( _arrayFloatHelper ); return true; }
	}
	return false;
}

::hx::Val FlxRandom_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"initialSeed") ) { initialSeed=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"internalSeed") ) { internalSeed=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxRandom_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"_arrayFloatHelper") ) { _arrayFloatHelper=ioValue.Cast< ::Array< Float > >(); return true; }
	}
	return false;
}

void FlxRandom_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("initialSeed",15,54,75,28));
	outFields->push(HX_("internalSeed",4e,fb,d0,37));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxRandom_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(FlxRandom_obj,initialSeed),HX_("initialSeed",15,54,75,28)},
	{::hx::fsFloat,(int)offsetof(FlxRandom_obj,internalSeed),HX_("internalSeed",4e,fb,d0,37)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxRandom_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< Float > */ ,(void *) &FlxRandom_obj::_arrayFloatHelper,HX_("_arrayFloatHelper",70,91,03,2c)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxRandom_obj_sMemberFields[] = {
	HX_("getObject_flixel_system_FlxSound",d4,f4,55,36),
	HX_("getObject_Array_String",01,58,9d,f8),
	HX_("initialSeed",15,54,75,28),
	HX_("int",ef,0c,50,00),
	HX_("float",9c,c5,96,02),
	HX_("weightedPick",58,64,ef,64),
	HX_("color",63,71,5c,4a),
	HX_("internalSeed",4e,fb,d0,37),
	::String(null()) };

static void FlxRandom_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxRandom_obj::_arrayFloatHelper,"_arrayFloatHelper");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxRandom_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxRandom_obj::_arrayFloatHelper,"_arrayFloatHelper");
};

#endif

::hx::Class FlxRandom_obj::__mClass;

static ::String FlxRandom_obj_sStaticFields[] = {
	HX_("_arrayFloatHelper",70,91,03,2c),
	::String(null())
};

void FlxRandom_obj::__register()
{
	FlxRandom_obj _hx_dummy;
	FlxRandom_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.math.FlxRandom",a1,6b,64,63);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxRandom_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxRandom_obj::__SetStatic;
	__mClass->mMarkFunc = FlxRandom_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxRandom_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxRandom_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxRandom_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxRandom_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxRandom_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxRandom_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxRandom_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_eba801adaf62ef5c_448_boot)
HXDLIN( 448)		_arrayFloatHelper = null();
            	}
}

} // end namespace flixel
} // end namespace math
