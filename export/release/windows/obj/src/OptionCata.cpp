// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_Option
#include <Option.h>
#endif
#ifndef INCLUDED_OptionCata
#include <OptionCata.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxAxes
#include <flixel/util/FlxAxes.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2cb69711273a85e6_21_new,"OptionCata","new",0x558602b2,"OptionCata.new","OptionsMenu.hx",21,0x7ae6dae1)
HX_LOCAL_STACK_FRAME(_hx_pos_2cb69711273a85e6_78_changeColor,"OptionCata","changeColor",0xff29ee25,"OptionCata.changeColor","OptionsMenu.hx",78,0x7ae6dae1)

void OptionCata_obj::__construct(Float x,Float y,::String _title,::Array< ::Dynamic> _options,::hx::Null< bool >  __o_middleType){
            		bool middleType = __o_middleType.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_2cb69711273a85e6_21_new)
HXLINE(  30)		this->middle = false;
HXLINE(  34)		super::__construct(x,y,null());
HXLINE(  35)		this->title = _title;
HXLINE(  36)		this->middle = middleType;
HXLINE(  37)		if (!(middleType)) {
HXLINE(  38)			this->makeGraphic(295,64,-16777216,null(),null());
            		}
HXLINE(  39)		this->set_alpha(((Float)0.4));
HXLINE(  41)		this->options = _options;
HXLINE(  43)		this->optionObjects =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  45)		Float _hx_tmp;
HXDLIN(  45)		if (middleType) {
HXLINE(  45)			_hx_tmp = ((Float)590.);
            		}
            		else {
HXLINE(  45)			_hx_tmp = x;
            		}
HXDLIN(  45)		int _hx_tmp1;
HXDLIN(  45)		if (middleType) {
HXLINE(  45)			_hx_tmp1 = 0;
            		}
            		else {
HXLINE(  45)			_hx_tmp1 = 16;
            		}
HXDLIN(  45)		this->titleObject =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,_hx_tmp,(y + _hx_tmp1),0,this->title,null(),null());
HXLINE(  46)		this->titleObject->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("muffnew.ttf",30,7e,b9,7a)),35,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE(  47)		this->titleObject->set_borderSize(( (Float)(3) ));
HXLINE(  49)		if (middleType) {
HXLINE(  51)			 ::flixel::text::FlxText _hx_tmp = this->titleObject;
HXDLIN(  51)			_hx_tmp->set_x((50 + (((Float)590.) - (this->titleObject->get_fieldWidth() / ( (Float)(2) )))));
            		}
            		else {
HXLINE(  54)			 ::flixel::text::FlxText _g = this->titleObject;
HXDLIN(  54)			Float _g1 = _g->x;
HXDLIN(  54)			Float _hx_tmp = (this->get_width() / ( (Float)(2) ));
HXDLIN(  54)			_g->set_x((_g1 + (_hx_tmp - (this->titleObject->get_fieldWidth() / ( (Float)(2) )))));
            		}
HXLINE(  56)		this->titleObject->scrollFactor->set(null(),null());
HXLINE(  58)		this->scrollFactor->set(null(),null());
HXLINE(  60)		{
HXLINE(  60)			int _g = 0;
HXDLIN(  60)			int _g1 = this->options->length;
HXDLIN(  60)			while((_g < _g1)){
HXLINE(  60)				_g = (_g + 1);
HXDLIN(  60)				int i = (_g - 1);
HXLINE(  62)				 ::Option opt = this->options->__get(i).StaticCast<  ::Option >();
HXLINE(  63)				Float text;
HXDLIN(  63)				if (middleType) {
HXLINE(  63)					text = ((Float)590.);
            				}
            				else {
HXLINE(  63)					text = ( (Float)(72) );
            				}
HXDLIN(  63)				Float text1 = ((this->titleObject->y + 54) + (46 * i));
HXDLIN(  63)				 ::flixel::text::FlxText text2 =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,text,text1,0,opt->getValue(),null(),null());
HXLINE(  64)				if (middleType) {
HXLINE(  66)					 ::flixel::util::FlxAxes axes = ::flixel::util::FlxAxes_obj::X_dyn();
HXDLIN(  66)					if (::hx::IsNull( axes )) {
HXLINE(  66)						axes = ::flixel::util::FlxAxes_obj::XY_dyn();
            					}
HXDLIN(  66)					bool _hx_tmp;
HXDLIN(  66)					switch((int)(axes->_hx_getIndex())){
            						case (int)0: case (int)2: {
HXLINE(  66)							_hx_tmp = true;
            						}
            						break;
            						default:{
HXLINE(  66)							_hx_tmp = false;
            						}
            					}
HXDLIN(  66)					if (_hx_tmp) {
HXLINE(  66)						int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN(  66)						text2->set_x(((( (Float)(_hx_tmp) ) - text2->get_width()) / ( (Float)(2) )));
            					}
HXDLIN(  66)					bool _hx_tmp1;
HXDLIN(  66)					switch((int)(axes->_hx_getIndex())){
            						case (int)1: case (int)2: {
HXLINE(  66)							_hx_tmp1 = true;
            						}
            						break;
            						default:{
HXLINE(  66)							_hx_tmp1 = false;
            						}
            					}
HXDLIN(  66)					if (_hx_tmp1) {
HXLINE(  66)						int _hx_tmp = ::flixel::FlxG_obj::height;
HXDLIN(  66)						text2->set_y(((( (Float)(_hx_tmp) ) - text2->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE(  68)				text2->setFormat((HX_("assets/fonts/",37,ff,a5,9c) + HX_("muffnew.ttf",30,7e,b9,7a)),35,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE(  69)				text2->set_borderSize(( (Float)(3) ));
HXLINE(  70)				text2->set_borderQuality(( (Float)(1) ));
HXLINE(  71)				text2->scrollFactor->set(null(),null());
HXLINE(  72)				this->optionObjects->add(text2).StaticCast<  ::flixel::text::FlxText >();
            			}
            		}
            	}

Dynamic OptionCata_obj::__CreateEmpty() { return new OptionCata_obj; }

void *OptionCata_obj::_hx_vtable = 0;

Dynamic OptionCata_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< OptionCata_obj > _hx_result = new OptionCata_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool OptionCata_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x142bb148) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x142bb148;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void OptionCata_obj::changeColor(int color){
            	HX_STACKFRAME(&_hx_pos_2cb69711273a85e6_78_changeColor)
HXDLIN(  78)		this->makeGraphic(295,64,color,null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(OptionCata_obj,changeColor,(void))


::hx::ObjectPtr< OptionCata_obj > OptionCata_obj::__new(Float x,Float y,::String _title,::Array< ::Dynamic> _options,::hx::Null< bool >  __o_middleType) {
	::hx::ObjectPtr< OptionCata_obj > __this = new OptionCata_obj();
	__this->__construct(x,y,_title,_options,__o_middleType);
	return __this;
}

::hx::ObjectPtr< OptionCata_obj > OptionCata_obj::__alloc(::hx::Ctx *_hx_ctx,Float x,Float y,::String _title,::Array< ::Dynamic> _options,::hx::Null< bool >  __o_middleType) {
	OptionCata_obj *__this = (OptionCata_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(OptionCata_obj), true, "OptionCata"));
	*(void **)__this = OptionCata_obj::_hx_vtable;
	__this->__construct(x,y,_title,_options,__o_middleType);
	return __this;
}

OptionCata_obj::OptionCata_obj()
{
}

void OptionCata_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(OptionCata);
	HX_MARK_MEMBER_NAME(title,"title");
	HX_MARK_MEMBER_NAME(options,"options");
	HX_MARK_MEMBER_NAME(optionObjects,"optionObjects");
	HX_MARK_MEMBER_NAME(titleObject,"titleObject");
	HX_MARK_MEMBER_NAME(middle,"middle");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void OptionCata_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(title,"title");
	HX_VISIT_MEMBER_NAME(options,"options");
	HX_VISIT_MEMBER_NAME(optionObjects,"optionObjects");
	HX_VISIT_MEMBER_NAME(titleObject,"titleObject");
	HX_VISIT_MEMBER_NAME(middle,"middle");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val OptionCata_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"title") ) { return ::hx::Val( title ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"middle") ) { return ::hx::Val( middle ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"options") ) { return ::hx::Val( options ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"titleObject") ) { return ::hx::Val( titleObject ); }
		if (HX_FIELD_EQ(inName,"changeColor") ) { return ::hx::Val( changeColor_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"optionObjects") ) { return ::hx::Val( optionObjects ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val OptionCata_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"title") ) { title=inValue.Cast< ::String >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"middle") ) { middle=inValue.Cast< bool >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"options") ) { options=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"titleObject") ) { titleObject=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"optionObjects") ) { optionObjects=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void OptionCata_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("title",98,15,3b,10));
	outFields->push(HX_("options",5e,33,fe,df));
	outFields->push(HX_("optionObjects",df,45,84,9f));
	outFields->push(HX_("titleObject",77,4a,cb,ab));
	outFields->push(HX_("middle",55,d3,5e,4c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo OptionCata_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(OptionCata_obj,title),HX_("title",98,15,3b,10)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(OptionCata_obj,options),HX_("options",5e,33,fe,df)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(OptionCata_obj,optionObjects),HX_("optionObjects",df,45,84,9f)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(OptionCata_obj,titleObject),HX_("titleObject",77,4a,cb,ab)},
	{::hx::fsBool,(int)offsetof(OptionCata_obj,middle),HX_("middle",55,d3,5e,4c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *OptionCata_obj_sStaticStorageInfo = 0;
#endif

static ::String OptionCata_obj_sMemberFields[] = {
	HX_("title",98,15,3b,10),
	HX_("options",5e,33,fe,df),
	HX_("optionObjects",df,45,84,9f),
	HX_("titleObject",77,4a,cb,ab),
	HX_("middle",55,d3,5e,4c),
	HX_("changeColor",d3,19,22,70),
	::String(null()) };

::hx::Class OptionCata_obj::__mClass;

void OptionCata_obj::__register()
{
	OptionCata_obj _hx_dummy;
	OptionCata_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("OptionCata",c0,81,06,7e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(OptionCata_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< OptionCata_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OptionCata_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OptionCata_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

