// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_openfl_ui_Keyboard
#include <openfl/ui/Keyboard.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_410ccb691917537a_815___getCharCode,"openfl.ui.Keyboard","__getCharCode",0x5c5ae14e,"openfl.ui.Keyboard.__getCharCode","openfl/ui/Keyboard.hx",815,0x5fb867bb)
namespace openfl{
namespace ui{

void Keyboard_obj::__construct() { }

Dynamic Keyboard_obj::__CreateEmpty() { return new Keyboard_obj; }

void *Keyboard_obj::_hx_vtable = 0;

Dynamic Keyboard_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Keyboard_obj > _hx_result = new Keyboard_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Keyboard_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0c5957a7;
}

int Keyboard_obj::_hx___getCharCode(int key,::hx::Null< bool >  __o_shift){
            		bool shift = __o_shift.Default(false);
            	HX_STACKFRAME(&_hx_pos_410ccb691917537a_815___getCharCode)
HXLINE( 816)		if (!(shift)) {
HXLINE( 818)			switch((int)(key)){
            				case (int)8: {
HXLINE( 821)					return 8;
            				}
            				break;
            				case (int)9: {
HXLINE( 823)					return 9;
            				}
            				break;
            				case (int)13: {
HXLINE( 825)					return 13;
            				}
            				break;
            				case (int)27: {
HXLINE( 827)					return 27;
            				}
            				break;
            				case (int)32: {
HXLINE( 829)					return 32;
            				}
            				break;
            				case (int)186: {
HXLINE( 831)					return 59;
            				}
            				break;
            				case (int)187: {
HXLINE( 833)					return 61;
            				}
            				break;
            				case (int)188: {
HXLINE( 835)					return 44;
            				}
            				break;
            				case (int)189: {
HXLINE( 837)					return 45;
            				}
            				break;
            				case (int)190: {
HXLINE( 839)					return 46;
            				}
            				break;
            				case (int)191: {
HXLINE( 841)					return 47;
            				}
            				break;
            				case (int)192: {
HXLINE( 843)					return 96;
            				}
            				break;
            				case (int)219: {
HXLINE( 845)					return 91;
            				}
            				break;
            				case (int)220: {
HXLINE( 847)					return 92;
            				}
            				break;
            				case (int)221: {
HXLINE( 849)					return 93;
            				}
            				break;
            				case (int)222: {
HXLINE( 851)					return 39;
            				}
            				break;
            			}
HXLINE( 854)			bool _hx_tmp;
HXDLIN( 854)			if ((key >= 48)) {
HXLINE( 854)				_hx_tmp = (key <= 57);
            			}
            			else {
HXLINE( 854)				_hx_tmp = false;
            			}
HXDLIN( 854)			if (_hx_tmp) {
HXLINE( 856)				return ((key - 48) + 48);
            			}
HXLINE( 859)			bool _hx_tmp1;
HXDLIN( 859)			if ((key >= 65)) {
HXLINE( 859)				_hx_tmp1 = (key <= 90);
            			}
            			else {
HXLINE( 859)				_hx_tmp1 = false;
            			}
HXDLIN( 859)			if (_hx_tmp1) {
HXLINE( 861)				return ((key - 65) + 97);
            			}
            		}
            		else {
HXLINE( 866)			switch((int)(key)){
            				case (int)48: {
HXLINE( 869)					return 41;
            				}
            				break;
            				case (int)49: {
HXLINE( 871)					return 33;
            				}
            				break;
            				case (int)50: {
HXLINE( 873)					return 64;
            				}
            				break;
            				case (int)51: {
HXLINE( 875)					return 35;
            				}
            				break;
            				case (int)52: {
HXLINE( 877)					return 36;
            				}
            				break;
            				case (int)53: {
HXLINE( 879)					return 37;
            				}
            				break;
            				case (int)54: {
HXLINE( 881)					return 94;
            				}
            				break;
            				case (int)55: {
HXLINE( 883)					return 38;
            				}
            				break;
            				case (int)56: {
HXLINE( 885)					return 42;
            				}
            				break;
            				case (int)57: {
HXLINE( 887)					return 40;
            				}
            				break;
            				case (int)186: {
HXLINE( 889)					return 58;
            				}
            				break;
            				case (int)187: {
HXLINE( 891)					return 43;
            				}
            				break;
            				case (int)188: {
HXLINE( 893)					return 60;
            				}
            				break;
            				case (int)189: {
HXLINE( 895)					return 95;
            				}
            				break;
            				case (int)190: {
HXLINE( 897)					return 62;
            				}
            				break;
            				case (int)191: {
HXLINE( 899)					return 63;
            				}
            				break;
            				case (int)192: {
HXLINE( 901)					return 126;
            				}
            				break;
            				case (int)219: {
HXLINE( 903)					return 123;
            				}
            				break;
            				case (int)220: {
HXLINE( 905)					return 124;
            				}
            				break;
            				case (int)221: {
HXLINE( 907)					return 125;
            				}
            				break;
            				case (int)222: {
HXLINE( 909)					return 34;
            				}
            				break;
            			}
HXLINE( 912)			bool _hx_tmp;
HXDLIN( 912)			if ((key >= 65)) {
HXLINE( 912)				_hx_tmp = (key <= 90);
            			}
            			else {
HXLINE( 912)				_hx_tmp = false;
            			}
HXDLIN( 912)			if (_hx_tmp) {
HXLINE( 914)				return ((key - 65) + 65);
            			}
            		}
HXLINE( 918)		bool _hx_tmp;
HXDLIN( 918)		if ((key >= 96)) {
HXLINE( 918)			_hx_tmp = (key <= 105);
            		}
            		else {
HXLINE( 918)			_hx_tmp = false;
            		}
HXDLIN( 918)		if (_hx_tmp) {
HXLINE( 920)			return ((key - 96) + 48);
            		}
HXLINE( 923)		switch((int)(key)){
            			case (int)8: {
HXLINE( 940)				return 8;
            			}
            			break;
            			case (int)13: {
HXLINE( 938)				return 13;
            			}
            			break;
            			case (int)46: {
HXLINE( 936)				return 127;
            			}
            			break;
            			case (int)106: {
HXLINE( 926)				return 42;
            			}
            			break;
            			case (int)107: {
HXLINE( 928)				return 43;
            			}
            			break;
            			case (int)108: {
HXLINE( 930)				return 44;
            			}
            			break;
            			case (int)110: {
HXLINE( 932)				return 45;
            			}
            			break;
            			case (int)111: {
HXLINE( 934)				return 46;
            			}
            			break;
            		}
HXLINE( 943)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Keyboard_obj,_hx___getCharCode,return )


Keyboard_obj::Keyboard_obj()
{
}

bool Keyboard_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"__getCharCode") ) { outValue = _hx___getCharCode_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Keyboard_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Keyboard_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Keyboard_obj::__mClass;

static ::String Keyboard_obj_sStaticFields[] = {
	HX_("__getCharCode",b9,62,90,0a),
	::String(null())
};

void Keyboard_obj::__register()
{
	Keyboard_obj _hx_dummy;
	Keyboard_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("openfl.ui.Keyboard",43,b4,37,9a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Keyboard_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Keyboard_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Keyboard_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Keyboard_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Keyboard_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace ui
