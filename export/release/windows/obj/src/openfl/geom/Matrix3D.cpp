// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix3D
#include <openfl/geom/Matrix3D.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_48294970c42d50e6_107_new,"openfl.geom.Matrix3D","new",0xe0591fd8,"openfl.geom.Matrix3D.new","openfl/geom/Matrix3D.hx",107,0x3acce238)
static const Float _hx_array_data_3d2e93e6_1[] = {
	1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_125_append,"openfl.geom.Matrix3D","append",0x481b8d62,"openfl.geom.Matrix3D.append","openfl/geom/Matrix3D.hx",125,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_338_appendTranslation,"openfl.geom.Matrix3D","appendTranslation",0x514252af,"openfl.geom.Matrix3D.appendTranslation","openfl/geom/Matrix3D.hx",338,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_452_copyRawDataFrom,"openfl.geom.Matrix3D","copyRawDataFrom",0x9938207f,"openfl.geom.Matrix3D.copyRawDataFrom","openfl/geom/Matrix3D.hx",452,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_808_identity,"openfl.geom.Matrix3D","identity",0xd35ee2c6,"openfl.geom.Matrix3D.identity","openfl/geom/Matrix3D.hx",808,0x3acce238)
static const Float _hx_array_data_3d2e93e6_7[] = {
	1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_1605_transpose,"openfl.geom.Matrix3D","transpose",0x1ba989f1,"openfl.geom.Matrix3D.transpose","openfl/geom/Matrix3D.hx",1605,0x3acce238)
namespace openfl{
namespace geom{

void Matrix3D_obj::__construct( ::openfl::_Vector::FloatVector v){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_107_new)
HXDLIN( 107)		bool _hx_tmp;
HXDLIN( 107)		if (::hx::IsNotNull( v )) {
HXDLIN( 107)			_hx_tmp = (v->get_length() == 16);
            		}
            		else {
HXDLIN( 107)			_hx_tmp = false;
            		}
HXDLIN( 107)		if (_hx_tmp) {
HXLINE( 109)			 ::openfl::_Vector::FloatVector vec = null();
HXDLIN( 109)			this->rawData = ( ( ::openfl::_Vector::FloatVector)(v->concat(vec)) );
            		}
            		else {
HXLINE( 113)			int length = null();
HXDLIN( 113)			bool fixed = null();
HXDLIN( 113)			this->rawData =  ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length,fixed,::Array_obj< Float >::fromData( _hx_array_data_3d2e93e6_1,16),true);
            		}
            	}

Dynamic Matrix3D_obj::__CreateEmpty() { return new Matrix3D_obj; }

void *Matrix3D_obj::_hx_vtable = 0;

Dynamic Matrix3D_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Matrix3D_obj > _hx_result = new Matrix3D_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Matrix3D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x45c06ede;
}

void Matrix3D_obj::append( ::openfl::geom::Matrix3D lhs){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_125_append)
HXLINE( 126)		Float m111 = this->rawData->get(0);
HXDLIN( 126)		Float m121 = this->rawData->get(4);
HXDLIN( 126)		Float m131 = this->rawData->get(8);
HXDLIN( 126)		Float m141 = this->rawData->get(12);
HXDLIN( 126)		Float m112 = this->rawData->get(1);
HXDLIN( 126)		Float m122 = this->rawData->get(5);
HXDLIN( 126)		Float m132 = this->rawData->get(9);
HXDLIN( 126)		Float m142 = this->rawData->get(13);
HXDLIN( 126)		Float m113 = this->rawData->get(2);
HXDLIN( 126)		Float m123 = this->rawData->get(6);
HXDLIN( 126)		Float m133 = this->rawData->get(10);
HXDLIN( 126)		Float m143 = this->rawData->get(14);
HXDLIN( 126)		Float m114 = this->rawData->get(3);
HXDLIN( 126)		Float m124 = this->rawData->get(7);
HXDLIN( 126)		Float m134 = this->rawData->get(11);
HXDLIN( 126)		Float m144 = this->rawData->get(15);
HXDLIN( 126)		Float m211 = lhs->rawData->get(0);
HXDLIN( 126)		Float m221 = lhs->rawData->get(4);
HXDLIN( 126)		Float m231 = lhs->rawData->get(8);
HXDLIN( 126)		Float m241 = lhs->rawData->get(12);
HXDLIN( 126)		Float m212 = lhs->rawData->get(1);
HXDLIN( 126)		Float m222 = lhs->rawData->get(5);
HXDLIN( 126)		Float m232 = lhs->rawData->get(9);
HXDLIN( 126)		Float m242 = lhs->rawData->get(13);
HXDLIN( 126)		Float m213 = lhs->rawData->get(2);
HXDLIN( 126)		Float m223 = lhs->rawData->get(6);
HXDLIN( 126)		Float m233 = lhs->rawData->get(10);
HXDLIN( 126)		Float m243 = lhs->rawData->get(14);
HXDLIN( 126)		Float m214 = lhs->rawData->get(3);
HXDLIN( 126)		Float m224 = lhs->rawData->get(7);
HXDLIN( 126)		Float m234 = lhs->rawData->get(11);
HXDLIN( 126)		Float m244 = lhs->rawData->get(15);
HXLINE( 159)		this->rawData->set(0,((((m111 * m211) + (m112 * m221)) + (m113 * m231)) + (m114 * m241)));
HXLINE( 160)		this->rawData->set(1,((((m111 * m212) + (m112 * m222)) + (m113 * m232)) + (m114 * m242)));
HXLINE( 161)		this->rawData->set(2,((((m111 * m213) + (m112 * m223)) + (m113 * m233)) + (m114 * m243)));
HXLINE( 162)		this->rawData->set(3,((((m111 * m214) + (m112 * m224)) + (m113 * m234)) + (m114 * m244)));
HXLINE( 164)		this->rawData->set(4,((((m121 * m211) + (m122 * m221)) + (m123 * m231)) + (m124 * m241)));
HXLINE( 165)		this->rawData->set(5,((((m121 * m212) + (m122 * m222)) + (m123 * m232)) + (m124 * m242)));
HXLINE( 166)		this->rawData->set(6,((((m121 * m213) + (m122 * m223)) + (m123 * m233)) + (m124 * m243)));
HXLINE( 167)		this->rawData->set(7,((((m121 * m214) + (m122 * m224)) + (m123 * m234)) + (m124 * m244)));
HXLINE( 169)		this->rawData->set(8,((((m131 * m211) + (m132 * m221)) + (m133 * m231)) + (m134 * m241)));
HXLINE( 170)		this->rawData->set(9,((((m131 * m212) + (m132 * m222)) + (m133 * m232)) + (m134 * m242)));
HXLINE( 171)		this->rawData->set(10,((((m131 * m213) + (m132 * m223)) + (m133 * m233)) + (m134 * m243)));
HXLINE( 172)		this->rawData->set(11,((((m131 * m214) + (m132 * m224)) + (m133 * m234)) + (m134 * m244)));
HXLINE( 174)		this->rawData->set(12,((((m141 * m211) + (m142 * m221)) + (m143 * m231)) + (m144 * m241)));
HXLINE( 175)		this->rawData->set(13,((((m141 * m212) + (m142 * m222)) + (m143 * m232)) + (m144 * m242)));
HXLINE( 176)		this->rawData->set(14,((((m141 * m213) + (m142 * m223)) + (m143 * m233)) + (m144 * m243)));
HXLINE( 177)		this->rawData->set(15,((((m141 * m214) + (m142 * m224)) + (m143 * m234)) + (m144 * m244)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,append,(void))

void Matrix3D_obj::appendTranslation(Float x,Float y,Float z){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_338_appendTranslation)
HXLINE( 339)		{
HXLINE( 339)			 ::openfl::_Vector::FloatVector _g = this->rawData;
HXDLIN( 339)			_g->set(12,(_g->get(12) + x));
            		}
HXLINE( 340)		{
HXLINE( 340)			 ::openfl::_Vector::FloatVector _g1 = this->rawData;
HXDLIN( 340)			_g1->set(13,(_g1->get(13) + y));
            		}
HXLINE( 341)		{
HXLINE( 341)			 ::openfl::_Vector::FloatVector _g2 = this->rawData;
HXDLIN( 341)			_g2->set(14,(_g2->get(14) + z));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,appendTranslation,(void))

void Matrix3D_obj::copyRawDataFrom( ::openfl::_Vector::FloatVector vector,::hx::Null< int >  __o_index,::hx::Null< bool >  __o_transpose){
            		int index = __o_index.Default(0);
            		bool transpose = __o_transpose.Default(false);
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_452_copyRawDataFrom)
HXLINE( 453)		if (transpose) {
HXLINE( 455)			this->transpose();
            		}
HXLINE( 458)		int length = (vector->get_length() - index);
HXLINE( 460)		{
HXLINE( 460)			int _g = 0;
HXDLIN( 460)			int _g1 = length;
HXDLIN( 460)			while((_g < _g1)){
HXLINE( 460)				_g = (_g + 1);
HXDLIN( 460)				int i = (_g - 1);
HXLINE( 462)				{
HXLINE( 462)					::Dynamic this1 = this->rawData;
HXDLIN( 462)					( ( ::openfl::_Vector::FloatVector)(this1) )->set(i,vector->get((i + index)));
            				}
            			}
            		}
HXLINE( 465)		if (transpose) {
HXLINE( 467)			this->transpose();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,copyRawDataFrom,(void))

void Matrix3D_obj::identity(){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_808_identity)
HXDLIN( 808)		int length = null();
HXDLIN( 808)		bool fixed = null();
HXDLIN( 808)		this->rawData =  ::openfl::_Vector::FloatVector_obj::__alloc( HX_CTX ,length,fixed,::Array_obj< Float >::fromData( _hx_array_data_3d2e93e6_7,16),true);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,identity,(void))

void Matrix3D_obj::transpose(){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_1605_transpose)
HXLINE(1606)		 ::openfl::_Vector::FloatVector oRawData = ( ( ::openfl::_Vector::FloatVector)(this->rawData->copy()) );
HXLINE(1607)		{
HXLINE(1607)			::Dynamic this1 = this->rawData;
HXDLIN(1607)			( ( ::openfl::_Vector::FloatVector)(this1) )->set(1,oRawData->get(4));
            		}
HXLINE(1608)		{
HXLINE(1608)			::Dynamic this2 = this->rawData;
HXDLIN(1608)			( ( ::openfl::_Vector::FloatVector)(this2) )->set(2,oRawData->get(8));
            		}
HXLINE(1609)		{
HXLINE(1609)			::Dynamic this3 = this->rawData;
HXDLIN(1609)			( ( ::openfl::_Vector::FloatVector)(this3) )->set(3,oRawData->get(12));
            		}
HXLINE(1610)		{
HXLINE(1610)			::Dynamic this4 = this->rawData;
HXDLIN(1610)			( ( ::openfl::_Vector::FloatVector)(this4) )->set(4,oRawData->get(1));
            		}
HXLINE(1611)		{
HXLINE(1611)			::Dynamic this5 = this->rawData;
HXDLIN(1611)			( ( ::openfl::_Vector::FloatVector)(this5) )->set(6,oRawData->get(9));
            		}
HXLINE(1612)		{
HXLINE(1612)			::Dynamic this6 = this->rawData;
HXDLIN(1612)			( ( ::openfl::_Vector::FloatVector)(this6) )->set(7,oRawData->get(13));
            		}
HXLINE(1613)		{
HXLINE(1613)			::Dynamic this7 = this->rawData;
HXDLIN(1613)			( ( ::openfl::_Vector::FloatVector)(this7) )->set(8,oRawData->get(2));
            		}
HXLINE(1614)		{
HXLINE(1614)			::Dynamic this8 = this->rawData;
HXDLIN(1614)			( ( ::openfl::_Vector::FloatVector)(this8) )->set(9,oRawData->get(6));
            		}
HXLINE(1615)		{
HXLINE(1615)			::Dynamic this9 = this->rawData;
HXDLIN(1615)			( ( ::openfl::_Vector::FloatVector)(this9) )->set(11,oRawData->get(14));
            		}
HXLINE(1616)		{
HXLINE(1616)			::Dynamic this10 = this->rawData;
HXDLIN(1616)			( ( ::openfl::_Vector::FloatVector)(this10) )->set(12,oRawData->get(3));
            		}
HXLINE(1617)		{
HXLINE(1617)			::Dynamic this11 = this->rawData;
HXDLIN(1617)			( ( ::openfl::_Vector::FloatVector)(this11) )->set(13,oRawData->get(7));
            		}
HXLINE(1618)		{
HXLINE(1618)			::Dynamic this12 = this->rawData;
HXDLIN(1618)			( ( ::openfl::_Vector::FloatVector)(this12) )->set(14,oRawData->get(11));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,transpose,(void))


::hx::ObjectPtr< Matrix3D_obj > Matrix3D_obj::__new( ::openfl::_Vector::FloatVector v) {
	::hx::ObjectPtr< Matrix3D_obj > __this = new Matrix3D_obj();
	__this->__construct(v);
	return __this;
}

::hx::ObjectPtr< Matrix3D_obj > Matrix3D_obj::__alloc(::hx::Ctx *_hx_ctx, ::openfl::_Vector::FloatVector v) {
	Matrix3D_obj *__this = (Matrix3D_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Matrix3D_obj), true, "openfl.geom.Matrix3D"));
	*(void **)__this = Matrix3D_obj::_hx_vtable;
	__this->__construct(v);
	return __this;
}

Matrix3D_obj::Matrix3D_obj()
{
}

void Matrix3D_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Matrix3D);
	HX_MARK_MEMBER_NAME(rawData,"rawData");
	HX_MARK_END_CLASS();
}

void Matrix3D_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(rawData,"rawData");
}

::hx::Val Matrix3D_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"append") ) { return ::hx::Val( append_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rawData") ) { return ::hx::Val( rawData ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"identity") ) { return ::hx::Val( identity_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"transpose") ) { return ::hx::Val( transpose_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"copyRawDataFrom") ) { return ::hx::Val( copyRawDataFrom_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"appendTranslation") ) { return ::hx::Val( appendTranslation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Matrix3D_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"rawData") ) { rawData=inValue.Cast<  ::openfl::_Vector::FloatVector >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Matrix3D_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("rawData",32,6c,18,ff));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Matrix3D_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::openfl::_Vector::FloatVector */ ,(int)offsetof(Matrix3D_obj,rawData),HX_("rawData",32,6c,18,ff)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Matrix3D_obj_sStaticStorageInfo = 0;
#endif

static ::String Matrix3D_obj_sMemberFields[] = {
	HX_("rawData",32,6c,18,ff),
	HX_("append",da,e1,d3,8f),
	HX_("appendTranslation",37,e1,3d,d6),
	HX_("copyRawDataFrom",07,7d,bd,2c),
	HX_("identity",3e,45,2f,b9),
	HX_("transpose",79,50,2f,4c),
	::String(null()) };

::hx::Class Matrix3D_obj::__mClass;

void Matrix3D_obj::__register()
{
	Matrix3D_obj _hx_dummy;
	Matrix3D_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("openfl.geom.Matrix3D",e6,93,2e,3d);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Matrix3D_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Matrix3D_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Matrix3D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Matrix3D_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace geom
